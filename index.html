<!DOCTYPE html><html lang="zh_cn">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta charset="utf-8">
    <meta name="description" content="打酱油的码农">
    <meta name="author" content="程光曦微">
    <title>程光曦微 | 程光曦微</title>
    
            <link href="assets/css/bootstrap.min.css" rel="stylesheet" type="text/css">
            <link href="assets/css/bootstrap-responsive.min.css" rel="stylesheet" type="text/css">
        <link href="assets/css/rst.css" rel="stylesheet" type="text/css">
        <link href="assets/css/code.css" rel="stylesheet" type="text/css">
        <link href="assets/css/colorbox.css" rel="stylesheet" type="text/css">
        <link href="assets/css/theme.css" rel="stylesheet" type="text/css">
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script>
    <![endif]-->
            <link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">

    
    
    
</head>
<body>
<!-- Menubar -->
<div class="navbar navbar-fixed-top" id="navbar">
    <div class="navbar-inner">
        <div class="container">

        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
        </a>

            <a class="brand" href=".">
            程光曦微
            </a>
            <!-- Everything you want hidden at 940px or less, place within here -->
            <div class="nav-collapse collapse">
                <ul class="nav">
                    
                <li><a href="archive.html">归档</a>
                </li><li><a href="categories/index.html">标签</a>
                </li><li><a href="galleries/index.html">图集</a>
                </li><li><a href="galleries/index.html">关于作者</a>
                </li><li><a href="rss.xml">RSS</a>

                </li></ul>
                <ul class="nav pull-right">
                
                
                    <li>
                </ul>
            </div>
        </div>
    </div>
</div>
<!-- End of Menubar -->
<div class="container-fluid" id="container-fluid">
    <!--Body content-->
    <div class="row-fluid">
    <div class="span2"></div>
    <div class="span8">
    
        <div class="postbox">
        <h1><a href="posts/zthread-source-Win32-thread-encapsulation.html">ZThread源码剖析——Win32线程封装</a>
        <small>  
             发表于: <time class="published" datetime="2014-01-20T10:16:04">2014-01-20 10:16</time>
        </small></h1>
        <hr>
        <h3>ZThread 线程最简使用</h3>
<p>想必大家对C++ 03中对线程库的标准支持缺失很是烦恼，C++11出现的时间太晚，ZThread是一个跨平台的线程库，可以使用面向对象的线程模型，API接口设计的很像Java，最简单的实现一个线程莫过于下面的代码：</p>
<div class="code"><pre><span class="vi">#include</span> <span class="o">&lt;</span><span class="nx">zthread</span><span class="p">/</span><span class="nx">Runnable.h</span><span class="o">&gt;</span>
<span class="vi">#include</span> <span class="o">&lt;</span><span class="nx">zthread</span><span class="p">/</span><span class="k">Thread</span><span class="bp">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="vi">#include</span> <span class="o">&lt;</span><span class="nx">iostream</span><span class="o">&gt;</span>

<span class="nx">using</span> <span class="nx">namespace</span> <span class="nx">std</span><span class="p">;</span>
<span class="nx">using</span> <span class="nx">namespace</span> <span class="nx">ZThread</span><span class="p">;</span>

<span class="nb">class</span> <span class="nx">TestRun</span> <span class="p">:</span> <span class="k">public</span> <span class="nf">Runnable</span>
<span class="p">{</span>
<span class="k">public</span><span class="p">:</span>
  <span class="bp">void</span> <span class="nb">run</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="nx">cout</span><span class="o">&lt;&lt;</span><span class="s2">"hello world"</span><span class="o">&lt;&lt;</span><span class="nx">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="bp">void</span> <span class="nx">testfun</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">Thread</span> <span class="nx">t0</span><span class="p">(</span><span class="nb">new</span> <span class="nx">TestRun</span><span class="p">());</span>
  <span class="k">Thread</span> <span class="nx">t1</span><span class="p">(</span><span class="nb">new</span> <span class="nx">TestRun</span><span class="p">());</span>
<span class="p">}</span>

<span class="nx">int</span> <span class="nx">main</span><span class="p">(</span><span class="nx">int</span> <span class="nx">argc</span><span class="p">,</span> <span class="nx">char</span><span class="o">*</span> <span class="nx">argv</span><span class="err">[</span><span class="cp">]</span>)
{
  testfun();
  return 0;
}
</pre></div>


<p>从上面可以明显的看出，只要实现一个Runnable的继承类，重新实现Runnable的纯虚函数run方法就可以实现出一个简单的线程类。使用的时候创建线程对象然后把自己实现好的对象指针传入进去即可。这个时候线程就可以正常运行，不过没有对线程异常进行捕捉和处理。</p>
<h3>Runnable Task的简单初窥</h3>
<p>Runnable这个class实现的非常简单，我这里就不详细复述了，他是一个抽象类，实现了一个纯虚函数的接口叫做run，所有的线程处理函数几乎都在这个函数下面大放光彩。</p>
<div class="code"><pre><span class="n">virtual</span> <span class="kt">void</span> <span class="n">run</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>


<p>ZThread中需要把Runable的对象包装成Task，即任务之说。
Task的实现是一个智能指针，关于ZThread的智能指针，我以后还会详细分析。
Task的实现也非常的简单，重要的是它同时提供了仿函数的接口，即重载了()：</p>
<div class="code"><pre><span class="kt">void</span> <span class="nf">operator</span><span class="p">()()</span> <span class="p">{</span>
  <span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<h3>ThreadOps线程操作</h3>
<p>ThreadOps是对线程的一个封装，我这里详细的分析一下ThreadOps的Win32实现：</p>
<h4>dispatch</h4>
<p>dispatch函数是一个static函数，并且声明的时候标明了stdcall，这个是Win API的常见写法，他的作用是给线程分发任务，作为线程的回调函数来使用。</p>
<div class="code"><pre>  <span class="c1">// 线程句柄</span>
  <span class="n">HANDLE</span> <span class="n">_hThread</span><span class="p">;</span>
  <span class="c1">// 线程ID</span>
  <span class="n">DWORD</span> <span class="n">_tid</span><span class="p">;</span>
</pre></div>


<p>这两个是ThreadOps唯一存在的两个私有的成员属性</p>
<h4>self</h4>
<p>返回当前线程对应的ThreadOps对象
代码后面的几个函数例如激活线程对象，判断ThreadOps对象是否对应当前线程，==的重载，优先级读取和设置等等很容易理解，这里就不在说明了。</p>
<h4>线程的创建</h4>
<p>使用spawn函数创建线程，当然为了保证线程拥有自己独立的全局存储区，Win32下面如果发现可以使用_beginthread和_endthread宏的话，就尽量使用这连个宏来控制线程，_beginthread实际上底层调用的就是CreateThread，但是他给线程封装了更为安全的全局存储区，在你是用一些C语言库函数对一些全局错误标志的修改可以起到一定的保护作用。
在创建线程的时候，传递dispatch的函数指针作为线程的回调函数，同时传递一个Runnable实例化好的指针作为线程函数的参数。</p>
<div class="code"><pre><span class="kt">bool</span> <span class="n">ThreadOps</span><span class="o">::</span><span class="n">spawn</span><span class="p">(</span><span class="n">Runnable</span><span class="o">*</span> <span class="n">task</span><span class="p">)</span> <span class="p">{</span>

<span class="c1">// Start the thread. 创建线程 注意用的是 _beginthreadex 把task作为参数传递进去</span>
<span class="cp">#if defined(HAVE_BEGINTHREADEX)</span>
  <span class="n">_hThread</span> <span class="o">=</span> <span class="p">(</span><span class="n">HANDLE</span><span class="p">)</span><span class="o">::</span><span class="n">_beginthreadex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">_dispatch</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_tid</span><span class="p">);</span>
<span class="cp">#else</span>
  <span class="n">_hThread</span> <span class="o">=</span> <span class="n">CreateThread</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">LPTHREAD_START_ROUTINE</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_dispatch</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_tid</span><span class="p">);</span>
<span class="cp">#endif</span>

  <span class="k">return</span> <span class="n">_hThread</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>


<h4>线程join</h4>
<p>线程等待结束使用WaitForSingleObjectEx，使用无限长等待，当等待结束线程句柄被关闭。</p>
<div class="code"><pre><span class="kt">bool</span> <span class="n">ThreadOps</span><span class="o">::</span><span class="n">join</span><span class="p">(</span><span class="n">ThreadOps</span><span class="o">*</span> <span class="n">ops</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">assert</span><span class="p">(</span><span class="n">ops</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">_tid</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">_hThread</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// 等待线程结束</span>
  <span class="k">if</span><span class="p">(</span><span class="o">::</span><span class="n">WaitForSingleObjectEx</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">_hThread</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">)</span> <span class="o">!=</span> <span class="n">WAIT_OBJECT_0</span><span class="p">)</span> 
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

  <span class="o">::</span><span class="n">CloseHandle</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">_hThread</span><span class="p">);</span>
  <span class="n">ops</span><span class="o">-&gt;</span><span class="n">_hThread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>


<h4>线程让步和YieldOps函数对象（仿函数）</h4>
<p>线程让步在Windows下面调用SwitchToThread API进行线程让步，但是SwitchToThread属于Platform API，其代码实现被封装在Kernel32.dll中，所以ZThread使用了YieldOps封装了一个仿函数以供外围接口调用。</p>
<div class="code"><pre><span class="kr">class</span> <span class="nx">YieldOps</span> <span class="p">{</span>

  <span class="nx">typedef</span> <span class="nx">BOOL</span> <span class="p">(</span><span class="o">*</span><span class="nx">Yield</span><span class="p">)(</span><span class="k">void</span><span class="p">);</span>
  <span class="nx">Yield</span> <span class="nx">_fnYield</span><span class="p">;</span> <span class="c1">// yield函数指针</span>

<span class="kr">public</span><span class="o">:</span>

  <span class="nx">YieldOps</span><span class="p">()</span> <span class="o">:</span> <span class="nx">_fnYield</span><span class="p">(</span><span class="nx">NULL</span><span class="p">)</span> <span class="p">{</span>

    <span class="nx">OSVERSIONINFO</span> <span class="nx">v</span><span class="p">;</span>
    <span class="nx">v</span><span class="p">.</span><span class="nx">dwOSVersionInfoSize</span> <span class="o">=</span> <span class="nx">sizeof</span><span class="p">(</span><span class="nx">OSVERSIONINFO</span><span class="p">);</span>

    <span class="c1">// NT 内核 找到SwitchToThread函数入口</span>
    <span class="k">if</span><span class="p">(</span><span class="o">::</span><span class="nx">GetVersionEx</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">dwPlatformId</span> <span class="o">==</span> <span class="nx">VER_PLATFORM_WIN32_NT</span><span class="p">))</span> <span class="p">{</span>
       <span class="nx">HINSTANCE</span> <span class="nx">hInst</span> <span class="o">=</span> <span class="o">::</span><span class="nx">GetModuleHandle</span><span class="p">(</span><span class="s2">"Kernel32.dll"</span><span class="p">);</span>
       <span class="k">if</span><span class="p">(</span><span class="nx">hInst</span> <span class="o">!=</span> <span class="nx">NULL</span><span class="p">)</span>
         <span class="nx">_fnYield</span> <span class="o">=</span> <span class="p">(</span><span class="nx">Yield</span><span class="p">)</span><span class="o">::</span><span class="nx">GetProcAddress</span><span class="p">(</span><span class="nx">hInst</span><span class="p">,</span> <span class="s2">"SwitchToThread"</span><span class="p">);</span>

       <span class="c1">// REMIND: possibly need to use _T() macro for these strings</span>
    <span class="p">}</span>

  <span class="p">}</span>

  <span class="c1">// 仿函数 括号重载 系统调用失败 尝试用sleep(0)来yield线程</span>
  <span class="nx">bool</span> <span class="nx">operator</span><span class="p">()()</span> <span class="p">{</span>

    <span class="c1">// Attempt to yield using the best function available</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">_fnYield</span> <span class="o">||</span> <span class="o">!</span><span class="nx">_fnYield</span><span class="p">())</span> 
      <span class="o">::</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  

    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>

  <span class="p">}</span>

<span class="p">};</span>
</pre></div>


<p>实际的ThreadOps::yield()只是初始化了一个静态的static YieldOps yielder：</p>
<div class="code"><pre><span class="kt">bool</span> <span class="n">ThreadOps</span><span class="o">::</span><span class="n">yield</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// 注意是静态的 只初始化了一次</span>
  <span class="k">static</span> <span class="n">YieldOps</span> <span class="n">yielder</span><span class="p">;</span>

  <span class="n">yielder</span><span class="p">();</span>

  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>


<h4>dispatch虚函数发威</h4>
<p>dispatch是类的静态成员，是没有this指针的，同时Win回调函数是不能使用class的成员函数的，所以在spawn函数中传递给了线程回调函数一个Runable指针参数，线程函数直接使用暴力强制类型转换得到正确的Runable对象指针
后续就是执行run方法，然后是线程资源回收</p>
<div class="code"><pre><span class="c1">// 分配线程任务 线程函数</span>
<span class="k">unsigned</span> <span class="k">int</span> <span class="n">__stdcall</span> <span class="n">ThreadOps</span><span class="o">::</span><span class="n">_dispatch</span><span class="p">(</span><span class="k">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// 参数传递进入 强制类型转化成为线程执行的task</span>
  <span class="n">Runnable</span><span class="o">*</span> <span class="k">task</span> <span class="o">=</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
  <span class="k">assert</span><span class="p">(</span><span class="k">task</span><span class="p">);</span>

  <span class="c1">// Run the task from the correct context</span>
  <span class="c1">// 线程处理函数 执行线程run的虚函数</span>
  <span class="k">task</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">();</span>

  <span class="c1">// Exit the thread</span>
<span class="p">#</span><span class="k">if</span> <span class="n">defined</span><span class="p">(</span><span class="no">HAVE_BEGINTHREADEX</span><span class="p">)</span>
  <span class="o">::</span><span class="n">_endthreadex</span><span class="p">(</span><span class="mh">0</span><span class="p">);</span>
<span class="p">#</span><span class="k">else</span>
  <span class="n">ExitThread</span><span class="p">(</span><span class="mh">0</span><span class="p">);</span>
<span class="p">#</span><span class="n">endif</span>

  <span class="k">return</span> <span class="mh">0</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>
            
        
    <p>
        <a href="posts/zthread-source-Win32-thread-encapsulation.html#disqus_thread" data-disqus-identifier="cache\posts\zthread-source-Win32-thread-encapsulation.html">Comments</a>


        </p></div>
        <div class="postbox">
        <h1><a href="posts/Sublime-Text-2.html">Sublime Text 2 使用心得</a>
        <small>  
             发表于: <time class="published" datetime="2013-08-18T21:40:02">2013-08-18 21:40</time>
        </small></h1>
        <hr>
        <!-- 
.. link: 
.. description: 
.. tags: Sublime Text 2,Plugin
.. date: 2013/08/18 21:40:02
.. title: Sublime Text 2 使用心得
.. slug: Sublime-Text-2
-->

<p>Sublime Text 2是一款现代轻量级跨平台文本编辑器，他配置比较方便（相对于Vim和Emacs而言），可定制性较强，插件丰富，更难能可贵的是快捷键和chrome差不多（Ctrl + N 新建标签页 Ctrl + W 关闭当前标签页 Ctrl + Shift + T 打开上一次关闭的文件）。</p>
<h3>概览</h3>
<p>主题采用Solarized Dark Color Scheme，侧边栏做过颜色的修饰</p>
<p><img alt="image" src="galleries/Sublime-Text-2/1.jpg"></p>
<h3>侧边栏颜色修改</h3>
<p>修改此文件%appdata%\Sublime Text 2\Packages\Theme - Default\Default.sublime-theme</p>
<p>有三处地方要修改</p>
<div class="code"><pre><span class="p">{</span>
    <span class="nt">"class"</span><span class="p">:</span> <span class="s2">"sidebar_tree"</span><span class="p">,</span>
    <span class="nt">"row_padding"</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
    <span class="nt">"indent"</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span>
    <span class="nt">"indent_offset"</span><span class="p">:</span> <span class="mi">17</span><span class="p">,</span>
    <span class="nt">"indent_top_level"</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="nt">"layer0.tint"</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">41</span><span class="p">],</span>
    <span class="nt">"layer0.opacity"</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="nt">"dark_content"</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">}</span><span class="err">,</span>

<span class="p">{</span>
    <span class="nt">"class"</span><span class="p">:</span> <span class="s2">"sidebar_label"</span><span class="p">,</span>
    <span class="nt">"color"</span><span class="p">:</span> <span class="p">[</span><span class="mi">150</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">150</span><span class="p">],</span>
    <span class="nt">"font.bold"</span><span class="p">:</span> <span class="kc">false</span>
    <span class="err">//</span> <span class="p">,</span> <span class="nt">"shadow_color"</span><span class="p">:</span> <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">250</span><span class="p">],</span> <span class="nt">"shadow_offset"</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="p">}</span><span class="err">,</span>

<span class="p">{</span>
    <span class="nt">"class"</span><span class="p">:</span> <span class="s2">"sidebar_container"</span><span class="p">,</span>
    <span class="nt">"layer0.tint"</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
    <span class="nt">"layer0.opacity"</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="nt">"layer0.draw_center"</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="nt">"layer0.inner_margin"</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="nt">"content_margin"</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="p">}</span><span class="err">,</span>
</pre></div>


<p>layer0.tint color 是JSON的语法，后面的是RGB颜色值，可以改成你喜欢的颜色，上面的是我自己的配置，效果如下：</p>
<p><img alt="image" src="galleries/Sublime-Text-2/2.jpg"></p>
<h3>快速跳转</h3>
<p>GotoAnything -&gt; Ctrl + P</p>
<p>这时候会出现这样的子窗口：</p>
<p><img alt="image" src="galleries/Sublime-Text-2/3.jpg"></p>
<p>你可以在任何当前打开的文件下面自由切换，使用@ 开头可以在当前文件中的函数切换</p>
<p><img alt="image" src="galleries/Sublime-Text-2/4.jpg"></p>
<p>使用# 可开头可以在当前文件中多有的符号中切换，</p>
<p><img alt="image" src="galleries/Sublime-Text-2/5.jpg"></p>
<p>使用: 开头加上行号可以在当前的制定行行号切换</p>
<p><img alt="image" src="galleries/Sublime-Text-2/6.jpg"></p>
<h3>文件自动保存</h3>
<p>在标签页上看到这种叉叉，意味着当前文件是保存过了的，</p>
<p><img alt="image" src="galleries/Sublime-Text-2/7.jpg"></p>
<p>,但是这种叉叉</p>
<p><img alt="image" src="galleries/Sublime-Text-2/8.jpg"></p>
<p>意味着当前文件没有被保存，一旦意外文件关闭会怎么办？是关闭之前弹出提示框？No，直接关闭，下次启动Subime Text会还原出上一次使用该文件时候的状态！</p>
<h3>安装Package Control</h3>
<p>这是一段Python代码，使用Ctrl + ~ 调出console，复制下面的代码回车，然后重启：</p>
<div class="code"><pre><span class="kn">import</span> <span class="nn">urllib2</span><span class="o">,</span><span class="nn">os</span><span class="p">;</span>
<span class="n">pf</span><span class="o">=</span><span class="s">'Package Control.sublime-package'</span><span class="p">;</span> <span class="n">ipp</span><span class="o">=</span><span class="n">sublime</span><span class="o">.</span><span class="n">installed_packages_path</span><span class="p">();</span>
<span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">ipp</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">ipp</span><span class="p">)</span> <span class="k">else</span> <span class="bp">None</span><span class="p">;</span> <span class="n">urllib2</span><span class="o">.</span><span class="n">install_opener</span><span class="p">(</span><span class="n">urllib2</span><span class="o">.</span><span class="n">build_opener</span><span class="p">(</span><span class="n">urllib2</span><span class="o">.</span><span class="n">ProxyHandler</span><span class="p">()));</span>
<span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ipp</span><span class="p">,</span><span class="n">pf</span><span class="p">),</span><span class="s">'wb'</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">urllib2</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s">'http://sublime.wbond.net/'</span><span class="o">+</span><span class="n">pf</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">' '</span><span class="p">,</span><span class="s">'%20'</span><span class="p">))</span><span class="o">.</span><span class="n">read</span><span class="p">());</span>
<span class="k">print</span> <span class="s">'Please restart Sublime Text to finish installation'</span>
</pre></div>


<p>重启Sublime Text之后，查看Preference菜单之下会有一个Package Control的子菜单</p>
<h3>命令匹配子窗口</h3>
<p>输入Ctrl + Shift + P，你会发现如下的子窗口，编辑器的所有的命令都会出现在在各子窗口里面，这里可以进行模糊匹配，输入install，你会看到如下效果：</p>
<p><img alt="image" src="galleries/Sublime-Text-2/9.jpg"></p>
<p>选中Package Control install package这个子命令，Sublime Text会列出所有的可用的插件集合（Github网络上的），你可以选择喜欢的安装。</p>
<h3>我推荐的一些插件</h3>
<p>Git</p>
<p>这个插件在Subime Text里面直接集成git命令，使用的确很方便，使用Ctrl + Shift + P，输入Git之后你就知道该怎么搞了。</p>
<p><img alt="image" src="galleries/Sublime-Text-2/10.jpg"></p>
<p>Sublime Code Intel</p>
<p>Python的自动补全很强大</p>
<p><img alt="image" src="galleries/Sublime-Text-2/11.jpg"></p>
<p>Sublime REPL</p>
<p>可以在Sublime Text里面直接执行脚本</p>
<p><img alt="image" src="galleries/Sublime-Text-2/12.jpg"></p>
<p>Markdown Preview</p>
<p>直接在浏览器预览Markdown语法的文件</p>
            
        
    <p>
        <a href="posts/Sublime-Text-2.html#disqus_thread" data-disqus-identifier="cache\posts\Sublime-Text-2.html">Comments</a>


        </p></div>
        <div class="postbox">
        <h1><a href="posts/wxWidgets-doubleBuffer.html">wxWidgets的双缓存与高级绘图wxGraphicsContext</a>
        <small>  
             发表于: <time class="published" datetime="2013-06-28T20:40:02">2013-06-28 20:40</time>
        </small></h1>
        <hr>
        <!-- 
.. link: 
.. description: 
.. tags: wxWidgets,
.. date: 2013/06/28 20:40:02
.. title: wxWidgets的双缓存与高级绘图wxGraphicsContext
.. slug: wxWidgets-doubleBuffer
-->

<p>防止绘图的闪烁，终极利器就是使用双缓存来防止闪烁，wxWidgets处理双缓存的类是wxAutoBufferedPaintDC，可以直接处理双缓存而不需要处理太多的问题。</p>
<div class="code"><pre><span class="kt">void</span> <span class="n">PicViewCtrl</span><span class="o">::</span><span class="n">OnPaint</span><span class="p">(</span><span class="n">wxPaintEvent</span><span class="o">&amp;</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">wxAutoBufferedPaintDC</span> <span class="n">dc</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
    <span class="n">PrepareDC</span><span class="p">(</span><span class="n">dc</span><span class="p">);</span>
    <span class="n">Render</span><span class="p">(</span><span class="n">dc</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>此时要注意style的设置：</p>
<div class="code"><pre><span class="n">SetBackgroundStyle</span><span class="p">(</span><span class="n">wxBG_STYLE_CUSTOM</span><span class="p">);</span>
</pre></div>


<p>所有的绘图放在Render(dc);里面，这样可以防止绘图闪烁。</p>
<p>另外一种方案是自己处理双缓存的函数：</p>
<div class="code"><pre><span class="k">if</span><span class="p">(</span><span class="n">IsDoubleBuffered</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">DrawBackground</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">xbase</span><span class="p">,</span> <span class="n">ybase</span><span class="p">,</span> <span class="n">xbase</span><span class="o">+</span><span class="n">virtualwidth</span><span class="p">,</span> <span class="n">ybase</span><span class="o">+</span><span class="n">virtualheight</span><span class="p">);</span>
    <span class="n">DrawGrid</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">xbase</span><span class="p">,</span> <span class="n">ybase</span><span class="p">,</span> <span class="n">xbase</span><span class="o">+</span><span class="n">virtualwidth</span><span class="p">,</span> <span class="n">ybase</span><span class="o">+</span><span class="n">virtualheight</span><span class="p">);</span>
    <span class="n">DrawFocusLine</span><span class="p">(</span><span class="n">dc</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">xindexstart</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">xindexend</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">yindexstart</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">yindexend</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">ShowOneCell</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="n">wxMemoryDC</span> <span class="n">mdc</span><span class="p">;</span>
    <span class="n">wxBitmap</span> <span class="n">bm</span> <span class="o">=</span> <span class="n">wxBitmap</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m_iXOffset</span><span class="o">+</span><span class="n">m_iCUWidth</span><span class="o">*</span><span class="n">m_iWidthPerPixel</span><span class="o">+</span><span class="mi">30</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">m_iYOffset</span><span class="o">+</span><span class="n">m_iCUHeight</span><span class="o">*</span><span class="n">m_iHeightPerPixel</span><span class="o">+</span><span class="mi">30</span><span class="p">);</span>
    <span class="n">mdc</span><span class="p">.</span><span class="n">SelectObject</span><span class="p">(</span><span class="n">bm</span><span class="p">);</span>
    <span class="n">DrawBackground</span><span class="p">(</span><span class="n">mdc</span><span class="p">,</span> <span class="n">xbase</span><span class="p">,</span> <span class="n">ybase</span><span class="p">,</span> <span class="n">xbase</span><span class="o">+</span><span class="n">virtualwidth</span><span class="p">,</span> <span class="n">ybase</span><span class="o">+</span><span class="n">virtualheight</span><span class="p">);</span>
    <span class="n">DrawGrid</span><span class="p">(</span><span class="n">mdc</span><span class="p">,</span> <span class="n">xbase</span><span class="p">,</span> <span class="n">ybase</span><span class="p">,</span> <span class="n">xbase</span><span class="o">+</span><span class="n">virtualwidth</span><span class="p">,</span> <span class="n">ybase</span><span class="o">+</span><span class="n">virtualheight</span><span class="p">);</span>
    <span class="n">DrawFocusLine</span><span class="p">(</span><span class="n">mdc</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">xindexstart</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">xindexend</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">yindexstart</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">yindexend</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">ShowOneCell</span><span class="p">(</span><span class="n">mdc</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
    <span class="n">dc</span><span class="p">.</span><span class="n">Blit</span><span class="p">(</span><span class="n">xbase</span><span class="p">,</span> <span class="n">ybase</span><span class="p">,</span> <span class="n">virtualwidth</span><span class="p">,</span> <span class="n">virtualheight</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mdc</span><span class="p">,</span> <span class="n">xbase</span><span class="p">,</span> <span class="n">ybase</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>wxGraphicsContext是高级绘图组建，在windows下面是GDIplus，支持alpha透明色，wxGraphicsContext使用和wxDC很像，但是想要使用他，在WIN32下需要</p>
<p>change the wxWidgets-2.8-12 source code setup.h from：</p>
<div class="code"><pre><span class="c">#ifndef wxUSE_GRAPHICS_CONTEXT</span>
<span class="c">#define wxUSE_GRAPHICS_CONTEXT 0</span>
<span class="c">#endif</span>
</pre></div>


<p>To</p>
<div class="code"><pre><span class="c">#ifndef wxUSE_GRAPHICS_CONTEXT</span>
<span class="c">#define wxUSE_GRAPHICS_CONTEXT 1</span>
<span class="c">#endif</span>
</pre></div>


<p>you must set <code>-USE_GDIPLUS=1</code></p>
<p>wxGraphicsContext的效果：</p>
<p><img alt="image" src="galleries/wxWidgets-doubleBuffer/result.jpg"></p>
            
        
    <p>
        <a href="posts/wxWidgets-doubleBuffer.html#disqus_thread" data-disqus-identifier="cache\posts\wxWidgets-doubleBuffer.html">Comments</a>


        </p></div>
        <div class="postbox">
        <h1><a href="posts/wxWidgets-Custom-UI.html">wxWidgets自定义绘图控件</a>
        <small>  
             发表于: <time class="published" datetime="2013-06-08T14:40:02">2013-06-08 14:40</time>
        </small></h1>
        <hr>
        <p>有时候系统提供的组件有可能不够你使用，比如我现在面临的显示YUV图像的控件，目前支持的功能是任意尺寸宏块或者CU的鼠标选定，鼠标拖拽确定范围，始终居中显示图片，鼠标滚轮翻页，ctrl加上滚轮放大或者缩小。</p>
<p>自定义wxControl第一步：</p>
<div class="code"><pre><span class="n">class</span> <span class="n">PicViewCtrl</span> <span class="o">:</span> <span class="n">public</span> <span class="n">wxControl</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">DECLARE_DYNAMIC_CLASS</span><span class="p">(</span><span class="n">PicViewCtrl</span><span class="p">);</span>
    <span class="c1">//….</span>
    <span class="n">DECLARE_EVENT_TABLE</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>


<p>显示YUV图像:</p>
<div class="code"><pre><span class="kt">void</span> <span class="n">PicViewCtrl</span><span class="o">::</span><span class="n">SetBitmap</span><span class="p">(</span><span class="n">wxBitmap</span> <span class="n">bitmap</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_bClearFlag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">m_cViewBitmap</span> <span class="o">=</span> <span class="n">bitmap</span><span class="p">;</span>
    <span class="n">m_CtrlSize</span><span class="p">.</span><span class="n">SetWidth</span><span class="p">(</span><span class="n">m_dScaleRate</span><span class="o">*</span><span class="n">m_cViewBitmap</span><span class="p">.</span><span class="n">GetWidth</span><span class="p">());</span>
    <span class="n">m_CtrlSize</span><span class="p">.</span><span class="n">SetHeight</span><span class="p">(</span><span class="n">m_dScaleRate</span><span class="o">*</span><span class="n">m_cViewBitmap</span><span class="p">.</span><span class="n">GetHeight</span><span class="p">());</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">SetSizeHints</span><span class="p">(</span><span class="n">m_CtrlSize</span><span class="p">);</span>
    <span class="n">GetParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">FitInside</span><span class="p">();</span>
    <span class="n">Refresh</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>重写OnPaint和OnEraseBkg</p>
<div class="code"><pre><span class="kt">void</span> <span class="n">PicViewCtrl</span><span class="o">::</span><span class="n">OnPaint</span><span class="p">(</span><span class="n">wxPaintEvent</span><span class="o">&amp;</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">wxPaintDC</span> <span class="n">dc</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
    <span class="n">Render</span><span class="p">(</span><span class="n">dc</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">PicViewCtrl</span><span class="o">::</span><span class="n">OnEraseBkg</span><span class="p">(</span><span class="n">wxEraseEvent</span><span class="o">&amp;</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">wxClientDC</span><span class="o">*</span> <span class="n">clientDC</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">.</span><span class="n">GetDC</span><span class="p">())</span>
        <span class="n">clientDC</span> <span class="o">=</span> <span class="n">new</span> <span class="n">wxClientDC</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
    <span class="n">wxDC</span><span class="o">*</span> <span class="n">pDC</span> <span class="o">=</span> <span class="n">clientDC</span> <span class="o">?</span> <span class="n">clientDC</span> <span class="o">:</span> <span class="n">event</span><span class="p">.</span><span class="n">GetDC</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">m_bClearFlag</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">pDC</span><span class="o">-&gt;</span><span class="n">Clear</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span>
        <span class="n">wxSize</span> <span class="n">size</span> <span class="o">=</span> <span class="n">GetClientSize</span><span class="p">();</span>
        <span class="n">wxString</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">s</span><span class="p">.</span><span class="n">Printf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"No picture to show!"</span><span class="p">),</span> <span class="n">size</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
        <span class="n">pDC</span><span class="o">-&gt;</span><span class="n">SetFont</span><span class="p">(</span><span class="o">*</span><span class="n">wxNORMAL_FONT</span><span class="p">);</span>
        <span class="n">pDC</span><span class="o">-&gt;</span><span class="n">GetTextExtent</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">w</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">height</span><span class="p">);</span>
        <span class="n">height</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="n">pDC</span><span class="o">-&gt;</span><span class="n">SetBrush</span><span class="p">(</span><span class="o">*</span><span class="n">wxTRANSPARENT_BRUSH</span><span class="p">);</span>
        <span class="n">pDC</span><span class="o">-&gt;</span><span class="n">SetPen</span><span class="p">(</span><span class="o">*</span><span class="n">wxLIGHT_GREY_PEN</span><span class="p">);</span>
        <span class="n">pDC</span><span class="o">-&gt;</span><span class="n">DrawLine</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
        <span class="n">pDC</span><span class="o">-&gt;</span><span class="n">DrawLine</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">pDC</span><span class="o">-&gt;</span><span class="n">DrawText</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">x</span><span class="o">-</span><span class="n">w</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">((</span><span class="n">size</span><span class="p">.</span><span class="n">y</span><span class="o">-</span><span class="p">(</span><span class="n">height</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">));</span>
        <span class="n">wxBitmap</span><span class="o">::</span><span class="n">CleanUpHandlers</span><span class="p">();</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">pDC</span><span class="o">-&gt;</span><span class="n">SetUserScale</span><span class="p">(</span><span class="n">m_dScaleRate</span><span class="p">,</span> <span class="n">m_dScaleRate</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">m_cViewBitmap</span><span class="p">.</span><span class="n">IsOk</span><span class="p">())</span>
        <span class="n">pDC</span><span class="o">-&gt;</span><span class="n">DrawBitmap</span><span class="p">(</span><span class="n">m_cViewBitmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">clientDC</span><span class="p">)</span>
        <span class="n">delete</span> <span class="n">clientDC</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Render负责画出选定的矩形方块</p>
<div class="code"><pre><span class="kt">void</span> <span class="n">PicViewCtrl</span><span class="o">::</span><span class="n">Render</span><span class="p">(</span><span class="n">wxDC</span><span class="o">&amp;</span> <span class="n">dc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">m_bClearFlag</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">dc</span><span class="p">.</span><span class="n">SetUserScale</span><span class="p">(</span><span class="n">m_dScaleRate</span><span class="p">,</span> <span class="n">m_dScaleRate</span><span class="p">);</span>
        <span class="n">dc</span><span class="p">.</span><span class="n">SetBrush</span><span class="p">(</span><span class="n">wxBrush</span><span class="p">(</span><span class="n">wxColor</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">128</span><span class="p">)));</span>
        <span class="n">dc</span><span class="p">.</span><span class="n">DrawRectangle</span><span class="p">(</span><span class="n">m_curLCUStart</span><span class="p">,</span> <span class="n">wxSize</span><span class="p">(</span><span class="n">m_curLCUEnd</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">m_curLCUStart</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">m_curLCUEnd</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">m_curLCUStart</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>在CSDN有关于MFC的两个函数的区别的讨论，现在摘录于下：</p>
<p>在MFC中任何一个window组件的绘图都是放在这两个member function中在设定上 OnEraseBkgnd()是用来画底图的而OnPaint()是用来画主要对象的</p>
<p>具体：<a href="http://bbs.csdn.net/topics/320086198">http://bbs.csdn.net/topics/320086198</a></p>
<p>ctrl加上滚轮放大或者缩小是使用了wxDC的SetUserScale，具体实现可以参考github中的<a href="https://github.com/XimingCheng/HEVCAnalyzer/blob/master/HEVCAnalyzer/PicViewCtrl.cpp">HEVCAnalyzer/PicViewCtrl.cpp</a></p>
<p>鼠标拖拽确定范围参考这里</p>
<p><a href="http://forums.wxwidgets.org/viewtopic.php?t=14575&amp;highlight=onmousemove">http://forums.wxwidgets.org/viewtopic.php?t=14575&amp;highlight=onmousemove</a></p>
<p>最终效果：</p>
<p><img alt="image" src="galleries/wxWidgets-Custom-UI/draw1.jpg"></p>
<p>其中的红色块会随着鼠标的移动而移动，默认设置是64x64大小，鼠标朝着蓝色方向拖动，滚轮会自动滚动，ctrl+滚轮放大缩小</p>
<p><img alt="image" src="galleries/wxWidgets-Custom-UI/draw2.jpg"></p>
<p>出现的问题：</p>
<p>The background color of the LCU rectangle is solid in Windows(画刷的alpha透明色在WIN32和GTK之下没有效果)，红色矩形应该是半透明的：</p>
<p><img alt="image" src="galleries/wxWidgets-Custom-UI/draw3.jpg"></p>
<p>Mac下面据说没有此问题，屌丝程序员，没有Mac机器测试。</p>
<p>WIN32后续解决方案：</p>
<p>The brush of the wxWidgets in Windows without GDIPlus enabled will not support the alpha channel, so rebuild the wxWidgets wxMSW with GDIPlus enabled is needed!</p>
            
        
    <p>
        <a href="posts/wxWidgets-Custom-UI.html#disqus_thread" data-disqus-identifier="cache\posts\wxWidgets-Custom-UI.html">Comments</a>


        </p></div>
        <div class="postbox">
        <h1><a href="posts/wxWidgets-UI.html">wxWidgets wxListCtrl与多线程UI更新</a>
        <small>  
             发表于: <time class="published" datetime="2013-05-31T20:10:06">2013-05-31 20:10</time>
        </small></h1>
        <hr>
        <p>很久没有编写GUI程序了，还是在本科的时候经常编写MFC程序，现在觉得作为一个IT人士，必须每隔上一段时间学习新的技术，否则会被淘汰。所以，我看了看wxWidgets这个号称跨平台的GUI库。</p>
<p>主要的目标是实现一个HEVC的码流分析器（<a href="https://github.com/XimingCheng/HEVCAnalyzer">HEVCAnalyzer</a>），这是一个长远的目标，估计要花上很长时间才能把功能完善，毕竟是我和一个同学在课余时间开发，而且目前遇到了很多的问题，我把这个星期我这方面遇到的问题总结一下，记录在此。</p>
<p>wxWidgets的使用我就不多说了，我的第一个目标就是编写一个YUV分析器，利用到了wxWidgets的AUI布局，下面是我的一个布局的草图：</p>
<p><img alt="image" src="galleries/wxWidgets-UI/design.jpg"></p>
<p>关于AUI布局，他是一个高级的布局管理，其中包含的属性Layers, Rows and Directions, Positions可以控制子窗口的位置，官方给了一个例子，效果如下（个别布局被我修改过）</p>
<p><img alt="image" src="galleries/wxWidgets-UI/demo.jpg"></p>
<p>所以我开始给我的项目程序设计了成了这个样子：</p>
<p><img alt="image" src="galleries/wxWidgets-UI/UI1.jpg"></p>
<p>其中左侧是YUV的缩率图列表使用了wxListCrtl，打开之后效果如下：</p>
<p><img alt="image" src="galleries/wxWidgets-UI/UI2.jpg"></p>
<p>其中这里使用了多线程更新UI，主要是因为如果YUV文件过大，打开处理时间过长，用户会感觉UI被卡死。使用线程控制UI更新，但是线程里面不能直接更新UI，目前是使用自定义消息发给父窗口，父窗口处理列表的更新：</p>
<p>启动线程：</p>
<div class="code"><pre><span class="k">if</span><span class="p">(</span><span class="n">m_pImage_list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">delete</span> <span class="n">m_pImage_list</span><span class="p">;</span>
    <span class="n">m_pImage_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">m_pImage_list</span> <span class="o">=</span> <span class="n">new</span> <span class="n">wxImageList</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">m_iSourceWidth</span><span class="o">*</span><span class="n">scaleRate</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">m_iSourceHeight</span><span class="o">*</span><span class="n">scaleRate</span><span class="p">);</span>
<span class="n">m_pThumbnalList</span><span class="o">-&gt;</span><span class="n">SetImageList</span><span class="p">(</span><span class="n">m_pImage_list</span><span class="p">,</span> <span class="n">wxIMAGE_LIST_NORMAL</span><span class="p">);</span>
<span class="n">m_pThumbThread</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ThumbnailThread</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">m_pImage_list</span><span class="p">,</span> <span class="n">m_iSourceWidth</span><span class="p">,</span> <span class="n">m_iSourceHeight</span><span class="p">,</span> <span class="n">bit</span><span class="p">,</span> <span class="n">sfile</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">m_pThumbThread</span><span class="o">-&gt;</span><span class="n">Create</span><span class="p">()</span> <span class="o">!=</span> <span class="n">wxTHREAD_NO_ERROR</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">wxLogError</span><span class="p">(</span><span class="n">wxT</span><span class="p">(</span><span class="s">"Can't create the thread!"</span><span class="p">));</span>
    <span class="n">delete</span> <span class="n">m_pThumbThread</span><span class="p">;</span>
    <span class="n">m_pThumbThread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">m_pThumbThread</span><span class="o">-&gt;</span><span class="n">Run</span><span class="p">()</span> <span class="o">!=</span> <span class="n">wxTHREAD_NO_ERROR</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">wxLogError</span><span class="p">(</span><span class="n">wxT</span><span class="p">(</span><span class="s">"Can't create the thread!"</span><span class="p">));</span>
        <span class="n">delete</span> <span class="n">m_pThumbThread</span><span class="p">;</span>
        <span class="n">m_pThumbThread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>线程中处理YUV to RGB转换：</p>
<div class="code"><pre><span class="kt">void</span><span class="o">*</span> <span class="n">ThumbnailThread</span><span class="o">::</span><span class="n">Entry</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_pImageList</span><span class="o">-&gt;</span><span class="n">RemoveAll</span><span class="p">();</span>
    <span class="n">TVideoIOYuv</span> <span class="n">cYUVIO</span><span class="p">;</span>
    <span class="n">cYUVIO</span><span class="p">.</span><span class="n">open</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">m_sYUVPath</span><span class="p">.</span><span class="n">mb_str</span><span class="p">(</span><span class="n">wxConvUTF8</span><span class="p">).</span><span class="n">data</span><span class="p">(),</span> <span class="nb">false</span><span class="p">,</span> <span class="n">m_iYUVBit</span><span class="p">,</span> <span class="n">m_iYUVBit</span><span class="p">,</span> <span class="n">m_iYUVBit</span><span class="p">,</span> <span class="n">m_iYUVBit</span><span class="p">);</span>
    <span class="n">TComPicYuv</span><span class="o">*</span> <span class="n">pcPicYuvOrg</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TComPicYuv</span><span class="p">;</span>
    <span class="n">pcPicYuvOrg</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">(</span> <span class="n">m_iSourceWidth</span><span class="p">,</span> <span class="n">m_iSourceHeight</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>

    <span class="n">wxBitmap</span> <span class="nf">bmp</span><span class="p">(</span><span class="n">m_iSourceWidth</span><span class="p">,</span> <span class="n">m_iSourceHeight</span><span class="p">,</span> <span class="mi">24</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">frame</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">cYUVIO</span><span class="p">.</span><span class="n">isEof</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">TestDestroy</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pad</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
        <span class="n">cYUVIO</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">pcPicYuvOrg</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>
        <span class="n">wxNativePixelData</span> <span class="nf">img</span><span class="p">(</span><span class="n">bmp</span><span class="p">);</span>
        <span class="n">wxNativePixelData</span><span class="o">::</span><span class="n">Iterator</span> <span class="n">p</span><span class="p">(</span><span class="n">img</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m_iSourceHeight</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">wxNativePixelData</span><span class="o">::</span><span class="n">Iterator</span> <span class="n">rowStart</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
            <span class="n">Pel</span><span class="o">*</span> <span class="n">pY</span> <span class="o">=</span> <span class="n">pcPicYuvOrg</span><span class="o">-&gt;</span><span class="n">getLumaAddr</span><span class="p">()</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="n">pcPicYuvOrg</span><span class="o">-&gt;</span><span class="n">getStride</span><span class="p">();</span>
            <span class="n">Pel</span><span class="o">*</span> <span class="n">pU</span> <span class="o">=</span> <span class="n">pcPicYuvOrg</span><span class="o">-&gt;</span><span class="n">getCbAddr</span><span class="p">()</span>   <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">pcPicYuvOrg</span><span class="o">-&gt;</span><span class="n">getCStride</span><span class="p">();</span>
            <span class="n">Pel</span><span class="o">*</span> <span class="n">pV</span> <span class="o">=</span> <span class="n">pcPicYuvOrg</span><span class="o">-&gt;</span><span class="n">getCrAddr</span><span class="p">()</span>   <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">pcPicYuvOrg</span><span class="o">-&gt;</span><span class="n">getCStride</span><span class="p">();</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_iSourceWidth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// YUV to RBG转换</span>
                <span class="c1">//此处省略, 具体可以参见Github项目中详细处理</span>
            <span class="p">}</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">rowStart</span><span class="p">;</span>
            <span class="n">p</span><span class="p">.</span><span class="n">OffsetY</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//bmp.SaveFile(_("test.bmp"), wxBITMAP_TYPE_BMP);</span>
        <span class="n">wxImage</span> <span class="n">bimg</span> <span class="o">=</span> <span class="n">bmp</span><span class="p">.</span><span class="n">ConvertToImage</span><span class="p">();</span>
        <span class="kt">double</span> <span class="n">scaleRate</span> <span class="o">=</span> <span class="mf">165.0</span><span class="o">/</span><span class="n">m_iSourceWidth</span><span class="p">;</span>
        <span class="n">wxImage</span> <span class="n">simg</span> <span class="o">=</span> <span class="n">bimg</span><span class="p">.</span><span class="n">Scale</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">m_iSourceWidth</span><span class="o">*</span><span class="n">scaleRate</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">m_iSourceHeight</span><span class="o">*</span><span class="n">scaleRate</span><span class="p">);</span>
        <span class="n">wxBitmap</span> <span class="nf">newbmp</span><span class="p">(</span><span class="n">simg</span><span class="p">);</span>
        <span class="n">m_pImageList</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">newbmp</span><span class="p">);</span>
        <span class="n">wxCommandEvent</span> <span class="nf">event</span><span class="p">(</span><span class="n">wxEVT_ADDANIMAGE_THREAD</span><span class="p">,</span> <span class="n">wxID_ANY</span><span class="p">);</span>
        <span class="n">event</span><span class="p">.</span><span class="n">SetInt</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
        <span class="c1">//m_pFrame-&gt;ProcessEvent(event);</span>
        <span class="c1">// this method can be used in Linux</span>
        <span class="n">wxPostEvent</span><span class="p">(</span><span class="n">m_pFrame</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
        <span class="n">frame</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pcPicYuvOrg</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">();</span>
    <span class="n">delete</span> <span class="n">pcPicYuvOrg</span><span class="p">;</span>
    <span class="n">pcPicYuvOrg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">wxCommandEvent</span> <span class="nf">event</span><span class="p">(</span><span class="n">wxEVT_END_THREAD</span><span class="p">,</span> <span class="n">wxID_ANY</span><span class="p">);</span>
    <span class="n">wxPostEvent</span><span class="p">(</span><span class="n">m_pFrame</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">wxThread</span><span class="o">::</span><span class="n">ExitCode</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>自定义消息处理函数（父窗口）：</p>
<div class="code"><pre><span class="kt">void</span> <span class="n">MainFrame</span><span class="o">::</span><span class="n">OnThreadAddImage</span><span class="p">(</span><span class="n">wxCommandEvent</span><span class="o">&amp;</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">event</span><span class="p">.</span><span class="n">GetInt</span><span class="p">();</span>
<span class="c1">//    wxString str;</span>
<span class="c1">//    str.Printf(wxT("frame %d added"), frame);</span>
<span class="c1">//    wxMessageBox(str);</span>
    <span class="n">wxListItem</span> <span class="n">item</span><span class="p">;</span>
    <span class="n">item</span><span class="p">.</span><span class="n">SetId</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
    <span class="n">wxString</span> <span class="n">text</span><span class="p">;</span>
    <span class="n">text</span><span class="p">.</span><span class="n">Printf</span><span class="p">(</span><span class="n">wxT</span><span class="p">(</span><span class="s">"POC %d"</span><span class="p">),</span> <span class="n">frame</span><span class="p">);</span>
    <span class="n">item</span><span class="p">.</span><span class="n">SetText</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
    <span class="n">item</span><span class="p">.</span><span class="n">SetImage</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
    <span class="n">m_pThumbnalList</span><span class="o">-&gt;</span><span class="n">InsertItem</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>遇到的问题:</p>
<p>1 Linux的wxThread估计有问题 ，无法启动线程</p>
<p><img alt="image" src="galleries/wxWidgets-UI/crash.jpg"></p>
<p>解决方法：</p>
<p>在wxApp的子类的构造函数添加线程初始化函数 XInitThreads();</p>
<div class="code"><pre><span class="n">class</span> <span class="n">HEVCodecApp</span> <span class="o">:</span> <span class="n">public</span> <span class="n">wxApp</span>
<span class="p">{</span>
<span class="nl">public:</span>
<span class="cp">#if defined(__UNIX__)</span>
    <span class="n">HEVCodecApp</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">XInitThreads</span><span class="p">();</span>
    <span class="p">}</span>
<span class="cp">#endif</span>
    <span class="kt">bool</span> <span class="n">OnInit</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>


<p>参考 <a href="http://forums.wxwidgets.org/viewtopic.php?t=32346&amp;p=139431">http://forums.wxwidgets.org/viewtopic.php?t=32346&amp;p=139431</a></p>
<p>2 wxListCtrl在Linux下面显示有问题，无法单列显示列表，这个是wxWidgets 2.8.12的bug，其例子也有这个bug：</p>
<p><img alt="image" src="galleries/wxWidgets-UI/bug.jpg"></p>
<p>我们打算使用wxHTMLListBox来解决这个bug</p>
            
        
    <p>
        <a href="posts/wxWidgets-UI.html#disqus_thread" data-disqus-identifier="cache\posts\wxWidgets-UI.html">Comments</a>


        </p></div>
        <div class="postbox">
        <h1><a href="posts/HEVC-basic-CU-learning.html">HEVC学习之CU划分小实验</a>
        <small>  
             发表于: <time class="published" datetime="2012-12-16T20:36:15">2012-12-16 20:36</time>
        </small></h1>
        <hr>
        <p>HEVC的CU的概念相信每个搞HEVC的童鞋都很清楚，但是怎么才能让HEVC的CU划分更加直观的表现出来呢，每次调试程序我的心中都有着下面这幅图，可是，我想把它直观的表现出来！谁叫咱智商不行，还是个没有用的程序猿，以后也毕不了业，也找不到工作呢！</p>
<p><img alt="image" src="galleries/HEVC-CU/cu.jpg"></p>
<p>好了，废话不多说，咱们不搞理论的，没有太多废话！基于HM 9.0</p>
<p>要想实际的打出CU划分的最终结果，我想了一个办法，就是修改HEVC的decoder，在CU最终划分的结果的地方把像素换成一个特殊值，比如luma改成0，就变成黑色的了。</p>
<p>怎么改呢，我代码才看了没多久，只好先研究一下decoder：</p>
<p>作为屌丝程序员，上来俺就找decoder的main函数，俺知道main函数里面这句话是关键：</p>
<div class="code"><pre><span class="c1">// call decoding function</span>
<span class="n">cTAppDecTop</span><span class="p">.</span><span class="n">decode</span><span class="p">();</span>
</pre></div>


<p>不多说，进去，在TAppDecTop::decode()函数里面俺知道这一句也是关键：</p>
<div class="code"><pre><span class="n">bNewPicture</span> <span class="o">=</span> <span class="n">m_cTDecTop</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="n">nalu</span><span class="p">,</span> <span class="n">m_iSkipFrame</span><span class="p">,</span> <span class="n">m_iPOCLastDisplay</span><span class="p">);</span>
</pre></div>


<p>不多说，进去，然后就豁然了一下，下面是一个对nalu.m_nalUnitType switch的语句，是对不同的nal分别解码，我要管的不是pps也不是sps就直接看解码一个slice：</p>
<div class="code"><pre><span class="k">return</span> <span class="nf">xDecodeSlice</span><span class="p">(</span><span class="n">nalu</span><span class="p">,</span> <span class="n">iSkipFrame</span><span class="p">,</span> <span class="n">iPOCLastDisplay</span><span class="p">);</span>
</pre></div>


<p>xDecodeSlice这个函数比较长，不过我就看上了一句话，这个函数的结尾部分：</p>
<div class="code"><pre><span class="c1">//  Decode a picture</span>
<span class="n">m_cGopDecoder</span><span class="p">.</span><span class="n">decompressSlice</span><span class="p">(</span><span class="n">nalu</span><span class="p">.</span><span class="n">m_Bitstream</span><span class="p">,</span> <span class="n">pcPic</span><span class="p">);</span>
</pre></div>


<p>TDecGop::decompressSlice(TComInputBitstream<em>pcBitstream, TComPic</em>&amp; rpcPic)这个函数俺也就看上一句话：</p>
<div class="code"><pre><span class="n">m_pcSliceDecoder</span><span class="o">-&gt;</span><span class="n">decompressSlice</span><span class="p">(</span> <span class="n">pcBitstream</span><span class="p">,</span> <span class="n">ppcSubstreams</span><span class="p">,</span> <span class="n">rpcPic</span><span class="p">,</span> <span class="n">m_pcSbacDecoder</span><span class="p">,</span> <span class="n">m_pcSbacDecoders</span><span class="p">);</span>
</pre></div>


<p>这个函数很关键，里面有这样的一个大循环：</p>
<div class="code"><pre><span class="k">for</span><span class="p">(</span> <span class="n">Int</span> <span class="n">iCUAddr</span> <span class="o">=</span> <span class="n">iStartCUAddr</span><span class="p">;</span> <span class="o">!</span><span class="n">uiIsLast</span> <span class="o">&amp;&amp;</span> <span class="n">iCUAddr</span> <span class="o">&lt;</span> <span class="n">rpcPic</span><span class="o">-&gt;</span><span class="n">getNumCUsInFrame</span><span class="p">();</span> <span class="n">iCUAddr</span> <span class="o">=</span> <span class="n">rpcPic</span><span class="o">-&gt;</span><span class="n">getPicSym</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">xCalculateNxtCUAddr</span><span class="p">(</span><span class="n">iCUAddr</span><span class="p">)</span> <span class="p">)</span>
  <span class="p">{</span><span class="cm">/*循环里面的代码*/</span><span class="p">}</span>
</pre></div>


<p>看到这个地方你想到了啥呢，没错，这是对LCU一个个循环的地方，在这个循环里面调用了m_pcCuDecoder-&gt;decodeCU( pcCU, uiIsLast ); decodeCU就是对一个LCU进行解码，到decodeCU里面看一看，发现他调用了xDecodeCU，而xDecodeCU是一个递归函数，是分别解码各个最终划分的CU，xDecodeCU里面有一个是否要一分为四的判断：</p>
<div class="code"><pre><span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="p">(</span> <span class="n">uiDepth</span> <span class="o">&lt;</span> <span class="n">pcCU</span><span class="o">-&gt;</span><span class="n">getDepth</span><span class="p">(</span> <span class="n">uiAbsPartIdx</span> <span class="p">)</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">uiDepth</span> <span class="o">&lt;</span> <span class="n">g_uiMaxCUDepth</span> <span class="o">-</span> <span class="n">g_uiAddCUDepth</span> <span class="p">)</span> <span class="p">)</span> <span class="o">||</span> <span class="n">bBoundary</span> <span class="p">)</span>
</pre></div>


<p>如果条件不满足，不就说明到达最终的CU的划分的地方了吗，好，在if出来的地方填上这样的一句话：</p>
<div class="code"><pre><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"uiLPelX uiTPelY uiRPelX uiBPelY "</span><span class="o">&lt;&lt;</span><span class="n">uiLPelX</span><span class="o">&lt;&lt;</span><span class="s">" "</span><span class="o">&lt;&lt;</span><span class="n">uiTPelY</span><span class="o">&lt;&lt;</span><span class="s">" "</span><span class="o">&lt;&lt;</span><span class="n">uiRPelX</span><span class="o">&lt;&lt;</span><span class="s">" "</span><span class="o">&lt;&lt;</span><span class="n">uiBPelY</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>


<p>运行解码器，解码一个I帧，输出的部分结果如下：</p>
<div class="code"><pre><span class="n">uiLPelX</span> <span class="n">uiTPelY</span> <span class="n">uiRPelX</span> <span class="n">uiBPelY</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">15</span> <span class="mi">15</span>
<span class="n">uiLPelX</span> <span class="n">uiTPelY</span> <span class="n">uiRPelX</span> <span class="n">uiBPelY</span> <span class="mi">16</span> <span class="mi">0</span> <span class="mi">31</span> <span class="mi">15</span>
<span class="n">uiLPelX</span> <span class="n">uiTPelY</span> <span class="n">uiRPelX</span> <span class="n">uiBPelY</span> <span class="mi">0</span> <span class="mi">16</span> <span class="mi">15</span> <span class="mi">31</span>
<span class="n">uiLPelX</span> <span class="n">uiTPelY</span> <span class="n">uiRPelX</span> <span class="n">uiBPelY</span> <span class="mi">16</span> <span class="mi">16</span> <span class="mi">31</span> <span class="mi">31</span>
<span class="n">uiLPelX</span> <span class="n">uiTPelY</span> <span class="n">uiRPelX</span> <span class="n">uiBPelY</span> <span class="mi">32</span> <span class="mi">0</span> <span class="mi">63</span> <span class="mi">31</span>
<span class="n">uiLPelX</span> <span class="n">uiTPelY</span> <span class="n">uiRPelX</span> <span class="n">uiBPelY</span> <span class="mi">0</span> <span class="mi">32</span> <span class="mi">15</span> <span class="mi">47</span>
<span class="n">uiLPelX</span> <span class="n">uiTPelY</span> <span class="n">uiRPelX</span> <span class="n">uiBPelY</span> <span class="mi">16</span> <span class="mi">32</span> <span class="mi">31</span> <span class="mi">47</span>
<span class="n">uiLPelX</span> <span class="n">uiTPelY</span> <span class="n">uiRPelX</span> <span class="n">uiBPelY</span> <span class="mi">0</span> <span class="mi">48</span> <span class="mi">15</span> <span class="mi">63</span>
<span class="n">uiLPelX</span> <span class="n">uiTPelY</span> <span class="n">uiRPelX</span> <span class="n">uiBPelY</span> <span class="mi">16</span> <span class="mi">48</span> <span class="mi">31</span> <span class="mi">63</span>
<span class="n">uiLPelX</span> <span class="n">uiTPelY</span> <span class="n">uiRPelX</span> <span class="n">uiBPelY</span> <span class="mi">32</span> <span class="mi">32</span> <span class="mi">63</span> <span class="mi">63</span>
</pre></div>


<p>可以明显看出这一个CU的划分是如下结果：</p>
<p><img alt="image" src="galleries/HEVC-CU/LCU1.jpg"></p>
<p>于是我就想个办法把每个小块的的两个坐标点存下来不就好了吗，于是在typedef.h我添加了如下代码：</p>
<div class="code"><pre><span class="c1">//cheng </span>
<span class="k">struct</span> <span class="n">PtPair</span>
<span class="p">{</span>
  <span class="n">UInt</span> <span class="n">_pt1x</span><span class="p">;</span>
  <span class="n">UInt</span> <span class="n">_pt1y</span><span class="p">;</span>
  <span class="n">UInt</span> <span class="n">_pt2x</span><span class="p">;</span>
  <span class="n">UInt</span> <span class="n">_pt2y</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>定义一个struct，保存一组坐标。在class TDecSlice里面添加一个私有成员：</p>
<div class="code"><pre><span class="nx">std</span><span class="p">::</span><span class="nl">vector</span><span class="o">&lt;</span><span class="nx">PtPair</span><span class="o">&gt;</span> <span class="nx">m_listLastCU</span>
</pre></div>


<p>用来保存一个slice里面所有的最终CU的划分结果</p>
<p>修改TDecCu::decodeCU的函数参数，把在class TDecSlice里面的m_listLastCU传递过去：</p>
<div class="code"><pre><span class="bp">Void</span> <span class="nx">TDecCu</span><span class="p">::</span><span class="nl">decodeCU</span><span class="p">(</span> <span class="nx">TComDataCU</span><span class="o">*</span> <span class="nx">pcCU</span><span class="p">,</span> <span class="nx">UInt</span><span class="o">&amp;</span> <span class="nx">ruiIsLast</span><span class="p">,</span> <span class="nx">std</span><span class="p">::</span><span class="nl">vector</span><span class="o">&lt;</span><span class="nx">PtPair</span><span class="o">&gt;&amp;</span> <span class="nb">list</span> <span class="p">)</span>
</pre></div>


<p>调用改为：</p>
<div class="code"><pre><span class="n">m_pcCuDecoder</span><span class="o">-&gt;</span><span class="n">decodeCU</span>     <span class="p">(</span> <span class="n">pcCU</span><span class="p">,</span> <span class="n">uiIsLast</span><span class="p">,</span> <span class="n">m_listLastCU</span> <span class="p">);</span>
</pre></div>


<p>classTDecCu也添加一个私有成员用来保存class TDecSlice传递过来的vector的指针：</p>
<div class="code"><pre><span class="nx">std</span><span class="p">::</span><span class="nl">vector</span><span class="o">&lt;</span><span class="nx">PtPair</span><span class="o">&gt;*</span> <span class="nx">m_plistPt</span><span class="p">;</span>
</pre></div>


<p>Void TDecCu::decodeCU( TComDataCU* pcCU,UInt&amp; ruiIsLast, std::vector<ptpair>&amp; list )函数里面开头部分添加：</ptpair></p>
<div class="code"><pre><span class="n">m_plistPt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">;</span>
</pre></div>


<p>decodeCU函数变成如下结果：</p>
<div class="code"><pre><span class="bp">Void</span> <span class="nx">TDecCu</span><span class="p">::</span><span class="nl">decodeCU</span><span class="p">(</span> <span class="nx">TComDataCU</span><span class="o">*</span> <span class="nx">pcCU</span><span class="p">,</span> <span class="nx">UInt</span><span class="o">&amp;</span> <span class="nx">ruiIsLast</span><span class="p">,</span> <span class="nx">std</span><span class="p">::</span><span class="nl">vector</span><span class="o">&lt;</span><span class="nx">PtPair</span><span class="o">&gt;&amp;</span> <span class="nb">list</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//cheng</span>
  <span class="n">m_plistPt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nb">list</span><span class="p">;</span>
  <span class="c1">//</span>
  <span class="k">if</span> <span class="p">(</span> <span class="nx">pcCU</span><span class="o">-&gt;</span><span class="nx">getSlice</span><span class="p">()</span><span class="o">-&gt;</span><span class="nx">getPPS</span><span class="p">()</span><span class="o">-&gt;</span><span class="nx">getUseDQP</span><span class="p">()</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="nx">setdQPFlag</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
  <span class="p">}</span>

<span class="vi">#if</span> <span class="o">!</span><span class="nx">REMOVE_BURST_IPCM</span>
  <span class="nx">pcCU</span><span class="o">-&gt;</span><span class="nx">setNumSucIPCM</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="vi">#endif</span>

  <span class="c1">// start from the top level CU</span>
  <span class="nx">xDecodeCU</span><span class="p">(</span> <span class="nx">pcCU</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">ruiIsLast</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>在TDecCu::xDecodeCU( TComDataCU* pcCU, UInt uiAbsPartIdx, UIntuiDepth, UInt&amp; ruiIsLast)这个函数里面的打印坐标信息的那一句话后面添加上：</p>
<div class="code"><pre>  <span class="n">pt</span><span class="p">.</span><span class="n">_pt1x</span> <span class="o">=</span> <span class="n">uiLPelX</span><span class="p">;</span> <span class="n">pt</span><span class="p">.</span><span class="n">_pt1y</span> <span class="o">=</span> <span class="n">uiTPelY</span><span class="p">;</span> <span class="n">pt</span><span class="p">.</span><span class="n">_pt2x</span> <span class="o">=</span> <span class="n">uiRPelX</span><span class="p">;</span> <span class="n">pt</span><span class="p">.</span><span class="n">_pt2y</span> <span class="o">=</span> <span class="n">uiBPelY</span><span class="p">;</span>
  <span class="n">m_plistPt</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">pt</span><span class="p">);</span>
</pre></div>


<p>这样的话，解码完一帧，m_listLastCU里面就保存了CU最终划分的结果。</p>
<p>TDecSlice::decompressSlice开头需要把vector清空以便于在解码下一帧的时候vector中的信息要重新记录</p>
<div class="code"><pre><span class="n">m_listLastCU</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</pre></div>


<p>最后在TDecSlice::decompressSlice的LCU的for循环的后面添加绘制CU最终边框的代码：</p>
<div class="code"><pre>  <span class="n">Pel</span><span class="o">*</span> <span class="n">pY</span> <span class="o">=</span> <span class="n">rpcPic</span><span class="o">-&gt;</span><span class="n">getPicYuvRec</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getLumaAddr</span><span class="p">();</span>
  <span class="n">UInt</span> <span class="n">stride</span> <span class="o">=</span> <span class="n">rpcPic</span><span class="o">-&gt;</span><span class="n">getPicYuvRec</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getStride</span><span class="p">();</span>
  <span class="k">for</span><span class="p">(</span><span class="n">UInt</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">m_listLastCU</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="n">UInt</span> <span class="n">y</span> <span class="o">=</span> <span class="n">m_listLastCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt1y</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">m_listLastCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt2y</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">for</span><span class="p">(</span><span class="n">UInt</span> <span class="n">x</span> <span class="o">=</span> <span class="n">m_listLastCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt1x</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">m_listLastCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt2x</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">m_listLastCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt1y</span> <span class="cm">/*|| y == m_listSCU[index]._pt2y*/</span><span class="p">)</span>
          <span class="n">pY</span><span class="p">[</span><span class="n">y</span><span class="o">*</span><span class="n">stride</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">m_listLastCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt1x</span> <span class="cm">/*|| x == m_listSCU[index]._pt2x*/</span><span class="p">)</span>
          <span class="n">pY</span><span class="p">[</span><span class="n">y</span><span class="o">*</span><span class="n">stride</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>


<p>解码一帧图像使用YUV播放器查看效果：</p>
<p><img alt="image" src="galleries/HEVC-CU/result1.jpg"></p>
<p>怎么办呢，在TDecSlice::decompressSlice函数里面添加一个类似的vector记录一下LCU，在class TDecSlice里面再添加一个私有成员std::vector<ptpair>m_listLCU;，TDecSlice::decompressSlice函数开始的地方清空vector：m_listLastCU.clear();</ptpair></p>
<p>在LCU的大大的for循环里面添加代码记录LCU划分的信息：</p>
<div class="code"><pre><span class="n">UInt</span> <span class="n">xpel</span> <span class="o">=</span> <span class="n">pcCU</span><span class="o">-&gt;</span><span class="n">getCUPelX</span><span class="p">();</span>
<span class="n">UInt</span> <span class="n">ypel</span> <span class="o">=</span> <span class="n">pcCU</span><span class="o">-&gt;</span><span class="n">getCUPelY</span><span class="p">();</span>
<span class="n">UInt</span> <span class="n">width</span> <span class="o">=</span> <span class="n">pcCU</span><span class="o">-&gt;</span><span class="n">getWidth</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">UInt</span> <span class="n">height</span> <span class="o">=</span> <span class="n">pcCU</span><span class="o">-&gt;</span><span class="n">getHeight</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">//std::cout&lt;&lt;"xpel :"&lt;&lt;xpel&lt;&lt;"ypel :"&lt;&lt;ypel&lt;&lt;"width : "&lt;&lt;width&lt;&lt;"height :"&lt;&lt;height&lt;&lt;std::endl;</span>
<span class="n">PtPair</span> <span class="n">pt</span><span class="p">;</span>
<span class="n">pt</span><span class="p">.</span><span class="n">_pt1x</span> <span class="o">=</span> <span class="n">xpel</span><span class="p">;</span> <span class="n">pt</span><span class="p">.</span><span class="n">_pt1y</span> <span class="o">=</span> <span class="n">ypel</span><span class="p">;</span> <span class="n">pt</span><span class="p">.</span><span class="n">_pt2x</span> <span class="o">=</span> <span class="n">xpel</span> <span class="o">+</span> <span class="n">width</span><span class="p">;</span> <span class="n">pt</span><span class="p">.</span><span class="n">_pt2y</span> <span class="o">=</span> <span class="n">ypel</span> <span class="o">+</span> <span class="n">height</span><span class="p">;</span>
<span class="n">m_listLCU</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pt</span><span class="p">);</span>
</pre></div>


<p>然后在刚才的画黑框的代码后面添加LCU的画白框的代码：</p>
<div class="code"><pre>  <span class="k">for</span><span class="p">(</span><span class="n">UInt</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">m_listLCU</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="n">UInt</span> <span class="n">y</span> <span class="o">=</span> <span class="n">m_listLCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt1y</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">m_listLCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt2y</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">for</span><span class="p">(</span><span class="n">UInt</span> <span class="n">x</span> <span class="o">=</span> <span class="n">m_listLCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt1x</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">m_listLCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt2x</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">m_listLCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt1y</span> <span class="cm">/*|| y == m_listLCU[index]._pt2y*/</span><span class="p">)</span>
          <span class="n">pY</span><span class="p">[</span><span class="n">y</span><span class="o">*</span><span class="n">stride</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">m_listLCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt1x</span> <span class="cm">/*|| x == m_listLCU[index]._pt2x*/</span><span class="p">)</span>
          <span class="n">pY</span><span class="p">[</span><span class="n">y</span><span class="o">*</span><span class="n">stride</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>


<p>运行解码器再试一下：</p>
<p><img alt="image" src="galleries/HEVC-CU/result2.jpg"></p>
<p>你可以很明显的看到LCU的大白色块！哈哈！</p>
<p>后面其实你可以发现：</p>
<p><img alt="image" src="galleries/HEVC-CU/LCU1.jpg"></p>
<p>和这个一模一样</p>
<p><img alt="image" src="galleries/HEVC-CU/LCU2.jpg"></p>
<p>注：以上画框的结果只能适用于I帧，对于P/B帧，由于解码我修改重建值也就修改了了P/B参考帧的像素值，导致P/B帧画框会出现一定混乱，不过对于P/B帧，vector里面存放的数据应该是对的！</p>
            
        
    <p>
        <a href="posts/HEVC-basic-CU-learning.html#disqus_thread" data-disqus-identifier="cache\posts\HEVC-basic-CU-learning.html">Comments</a>


        </p></div>
        <div class="postbox">
        <h1><a href="posts/oh-memory-leak.html">内存泄露，我擦</a>
        <small>  
             发表于: <time class="published" datetime="2012-11-18T00:31:01">2012-11-18 00:31</time>
        </small></h1>
        <hr>
        <!-- 
.. link: 
.. description: 
.. tags: 内存泄露,C++,VisualLeak Detector,valgrind
.. date: 2012/11/18 00:31:01
.. title: 内存泄露，我擦
.. slug: oh-memory-leak
-->

<p>在这个快节奏的环境下，男人怕泄，女人怕漏。一个C/C++程序猿怕啥呢——泄露。下面是我从别的地方摘录的一段[1]。</p>
<p>“C/C++编译的程序的内存分配分为以下几个部分：栈区（stack）——由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆区（heap）——一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。全局区（静态区）（static）——全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。文字常量区——常量字符串就是放在这里的，程序结束后由系统释放。程序代码区——存放函数体的二进制代码。”</p>
<p>Memory Leak中文翻译为内存泄露，这是一个令人头疼的话题，因为由程序猿手动动态分配的内存一般都在heap上，这个蛋疼的东西总困扰着C/C++程序猿，如果不手动释放该内存，在程序退出之前，这一块内存是不会被释放的。</p>
<p>有人这时候就站出来了，你怎么能这么懒呢，用完释放不就得了吗。我只能说，“猿”非圣贤，咋就不能有个疏忽的地方呢。一旦疏忽就悲剧了，代码逻辑简单的还好，一旦复杂起来，恐怕只有上帝才知道是哪个地方泄露了。都这样了，当然咱们不多说废话了，我来介绍两个专搞内存泄露的工具。</p>
<p>Windows工具——VisualLeak Detector(VLD)，这货是用在Visual Studio上面的，至于如果你使用MingW之类的我还木有研究过。官方网站是：<a href="http://vld.codeplex.com/" title="http://vld.codeplex.com/">VisualLeak Detector(VLD)</a></p>
<p>下载下来，安装，把安装目录下面的src目录添加到VisualStudio的include path里面，把lib目录添加到Visual Studio的lib path里面，注意有lib目录有两个分别代表的是x86和x64，这要根据你的工程的配置来选择使用哪一个。好了一切就绪了，我们试一把。</p>
<p>首先编写一个非常简单的泄露程序，虽然我在一些面试题目上面看到说这个不算内存泄露。</p>
<div class="code"><pre><span class="vi">#include</span> <span class="o">&lt;</span><span class="nx">iostream</span><span class="o">&gt;</span>

<span class="nx">int</span> <span class="nx">main</span><span class="p">(</span><span class="nx">int</span> <span class="nx">argc</span><span class="p">,</span> <span class="nx">char</span><span class="o">**</span> <span class="nx">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nx">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">new</span> <span class="nx">int</span><span class="err">[</span><span class="mi">10</span><span class="cp">]</span>;
    return 0;
}
</pre></div>


<p>使用F5直接调试运行一下，观察output的最后一段：</p>
<div class="code"><pre><span class="n">WARNING</span><span class="o">:</span> <span class="n">Visual</span> <span class="n">Leak</span> <span class="n">Detector</span> <span class="n">detected</span> <span class="n">memory</span> <span class="n">leaks</span><span class="o">!</span>
<span class="o">----------</span> <span class="n">Block</span> <span class="mi">1</span> <span class="n">at</span> <span class="mh">0x00379580</span><span class="o">:</span> <span class="mi">40</span> <span class="n">bytes</span> <span class="o">----------</span>
  <span class="n">Call</span> <span class="n">Stack</span><span class="o">:</span>
    <span class="n">e</span><span class="o">:\</span><span class="n">projects</span><span class="o">\</span><span class="n">leak</span><span class="o">\</span><span class="n">leak</span><span class="o">\</span><span class="n">source</span><span class="o">.</span><span class="na">cpp</span> <span class="o">(</span><span class="mi">6</span><span class="o">):</span> <span class="n">leak</span><span class="o">.</span><span class="na">exe</span><span class="o">!</span><span class="n">main</span> <span class="o">+</span> <span class="mh">0x7</span> <span class="n">bytes</span>
    <span class="n">f</span><span class="o">:\</span><span class="n">dd</span><span class="o">\</span><span class="n">vctools</span><span class="o">\</span><span class="n">crt_bld</span><span class="o">\</span><span class="n">self_x86</span><span class="o">\</span><span class="n">crt</span><span class="o">\</span><span class="n">src</span><span class="o">\</span><span class="n">crtexe</span><span class="o">.</span><span class="na">c</span> <span class="o">(</span><span class="mi">536</span><span class="o">):</span> <span class="n">leak</span><span class="o">.</span><span class="na">exe</span><span class="o">!</span><span class="n">__tmainCRTStartup</span> <span class="o">+</span> <span class="mh">0x19</span> <span class="n">bytes</span>
    <span class="n">f</span><span class="o">:\</span><span class="n">dd</span><span class="o">\</span><span class="n">vctools</span><span class="o">\</span><span class="n">crt_bld</span><span class="o">\</span><span class="n">self_x86</span><span class="o">\</span><span class="n">crt</span><span class="o">\</span><span class="n">src</span><span class="o">\</span><span class="n">crtexe</span><span class="o">.</span><span class="na">c</span> <span class="o">(</span><span class="mi">377</span><span class="o">):</span> <span class="n">leak</span><span class="o">.</span><span class="na">exe</span><span class="o">!</span><span class="n">mainCRTStartup</span>
    <span class="mh">0x765</span><span class="n">CED6C</span> <span class="o">(</span><span class="n">File</span> <span class="n">and</span> <span class="n">line</span> <span class="n">number</span> <span class="n">not</span> <span class="n">available</span><span class="o">):</span> <span class="n">kernel32</span><span class="o">.</span><span class="na">dll</span><span class="o">!</span><span class="n">BaseThreadInitThunk</span> <span class="o">+</span> <span class="mh">0x12</span> <span class="n">bytes</span>
    <span class="mh">0x77</span><span class="n">B8377B</span> <span class="o">(</span><span class="n">File</span> <span class="n">and</span> <span class="n">line</span> <span class="n">number</span> <span class="n">not</span> <span class="n">available</span><span class="o">):</span> <span class="n">ntdll</span><span class="o">.</span><span class="na">dll</span><span class="o">!</span><span class="n">RtlInitializeExceptionChain</span> <span class="o">+</span> <span class="mi">0</span><span class="n">xEF</span> <span class="n">bytes</span>
    <span class="mh">0x77</span><span class="n">B8374E</span> <span class="o">(</span><span class="n">File</span> <span class="n">and</span> <span class="n">line</span> <span class="n">number</span> <span class="n">not</span> <span class="n">available</span><span class="o">):</span> <span class="n">ntdll</span><span class="o">.</span><span class="na">dll</span><span class="o">!</span><span class="n">RtlInitializeExceptionChain</span> <span class="o">+</span> <span class="mi">0</span><span class="n">xC2</span> <span class="n">bytes</span>
  <span class="n">Data</span><span class="o">:</span>
    <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span>    <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span>    <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span>    <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span>     <span class="o">........</span> <span class="o">........</span>
    <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span>    <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span>    <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span>    <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span>     <span class="o">........</span> <span class="o">........</span>
    <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span>    <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span>                                   <span class="o">........</span> <span class="o">........</span>


<span class="n">Visual</span> <span class="n">Leak</span> <span class="n">Detector</span> <span class="n">detected</span> <span class="mi">1</span> <span class="n">memory</span> <span class="n">leak</span> <span class="o">(</span><span class="mi">76</span> <span class="n">bytes</span><span class="o">).</span>
<span class="n">Largest</span> <span class="n">number</span> <span class="n">used</span><span class="o">:</span> <span class="mi">76</span> <span class="n">bytes</span><span class="o">.</span>
<span class="n">Total</span> <span class="n">allocations</span><span class="o">:</span> <span class="mi">76</span> <span class="n">bytes</span><span class="o">.</span>
<span class="n">Visual</span> <span class="n">Leak</span> <span class="n">Detector</span> <span class="k">is</span> <span class="n">now</span> <span class="n">exiting</span><span class="o">.</span>
<span class="n">The</span> <span class="n">program</span> <span class="s1">'[7652] leak.exe'</span> <span class="n">has</span> <span class="n">exited</span> <span class="k">with</span> <span class="n">code</span> <span class="mi">0</span> <span class="o">(</span><span class="mh">0x0</span><span class="o">).</span>
</pre></div>


<p>这里就很明白了把，这个vld工具可以打印出泄露调用的堆栈，双击任意错误处，可以到达错误的地方，e:\projects\leak\leak\source.cpp (6): leak.exe!main + 0x7 bytes双击这句话就定位到了main函数的第六行。哈哈，很方便吧！</p>
<p>使用Linux的童鞋要鄙视我们了，人家都是命令行的高手，不屑于使用GUI工具，再说也木有Visual Studio，Vim Emacs之类的利器可以秒杀Visual Studio。这时候如何定位泄露的地方呢？现在推出终极杀人魔——valgrind。官网：<a href="http://www.valgrind.org" title="http://www.valgrind.org">valgrind</a></p>
<p>使用debian和ubuntu的童鞋可以使用apt-get命令安装此软件。</p>
<p>首先使用gcc的童鞋首先编译的时候加上-g的debug选项，优化最好是使用-o0，然后如果你的程序运行是使用如下的参数方式：</p>
<div class="code"><pre><span class="n">myprog</span> <span class="n">arg1</span> <span class="n">arg2</span>
</pre></div>


<p>现在就改成下面的方式：</p>
<div class="code"><pre><span class="n">valgrind</span><span class="o">--</span><span class="n">leak</span><span class="o">-</span><span class="n">check</span><span class="o">=</span><span class="n">yes</span> <span class="n">myprog</span> <span class="n">arg1</span> <span class="n">arg2</span>
</pre></div>


<p>等到程序结束的时候就可以看到泄露的地方啦。（本人Linux菜鸟，没法给大家演示了，不然又要重启进入Linux或者打开卡卡的虚拟机）</p>
<p>哈哈，到这里了，泄露还是否那么可怕呢。我给大家一张恐怖的泄露截图吧，以供娱乐：</p>
<p><img alt="image" src="galleries/memory-leak/leak.jpg"></p>
<p>参考资料：</p>
<p>[1] <a href="http://bbs.csdn.net/topics/390050717">http://bbs.csdn.net/topics/390050717</a></p>
<p>[2] <a href="http://vld.codeplex.com/documentation">http://vld.codeplex.com/documentation</a></p>
<p>[3] <a href="http://www.valgrind.org/docs/manual/quick-start.html#quick-start.mcrun">http://www.valgrind.org/docs/manual/quick-start.html#quick-start.mcrun</a></p>
            
        
    <p>
        <a href="posts/oh-memory-leak.html#disqus_thread" data-disqus-identifier="cache\posts\oh-memory-leak.html">Comments</a>


        </p></div>
    
<div>
<ul class="pager">
</ul>
</div>

    
        
       <script type="text/javascript">var disqus_shortname="nikolademo";(function(){var a=document.createElement("script");a.async=true;a.type="text/javascript";a.src="http://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)}());</script>


	


    </div>
    </div>
    <!--End of body content-->
</div>
<div class="footerbox">
    Contents © 2014         <a href="mailto:chengximing1989@gmail.com">程光曦微</a> - Powered by         <a href="http://getnikola.com">Nikola</a>         
</div>

            <script src="assets/js/jquery-1.10.2.min.js" type="text/javascript"></script>
            <script src="assets/js/bootstrap.min.js" type="text/javascript"></script>
        <script src="assets/js/jquery.colorbox-min.js" type="text/javascript"></script>


	
<!-- Social buttons -->
<div id="addthisbox" class="addthis_toolbox addthis_peekaboo_style addthis_default_style addthis_label_style addthis_32x32_style">
<a class="addthis_button_more">Share</a>
<ul><li><a class="addthis_button_facebook"></a>
</li><li><a class="addthis_button_google_plusone_share"></a>
</li><li><a class="addthis_button_linkedin"></a>
</li><li><a class="addthis_button_twitter"></a>
</li></ul>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-4f7088a56bb93798"></script>
<!-- End of social buttons -->


    <script type="text/javascript">jQuery("a.image-reference").colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});
    $(window).on('hashchange', function(){
        if (location.hash && $(location.hash)[0]) {
            $('body').animate({scrollTop: $(location.hash).offset().top - $('#navbar').outerHeight(true)*1.2 }, 1);
        }
    });
    $(document).ready(function(){$(window).trigger('hashchange')});
    </script>
   
   
</body>
</html>