<!DOCTYPE html><html lang="zh_cn">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta charset="utf-8">
    <meta name="description" content="打酱油的码农">
    <meta name="author" content="程光曦微">
    <title>程光曦微 | 程光曦微</title>
    
            <link href="assets/css/bootstrap.min.css" rel="stylesheet" type="text/css">
            <link href="assets/css/bootstrap-responsive.min.css" rel="stylesheet" type="text/css">
        <link href="assets/css/rst.css" rel="stylesheet" type="text/css">
        <link href="assets/css/code.css" rel="stylesheet" type="text/css">
        <link href="assets/css/colorbox.css" rel="stylesheet" type="text/css">
        <link href="assets/css/theme.css" rel="stylesheet" type="text/css">
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script>
    <![endif]-->
            <link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">

    
    
    
</head>
<body>
<!-- Menubar -->
<div class="navbar navbar-fixed-top" id="navbar">
    <div class="navbar-inner">
        <div class="container">

        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
        </a>

            <a class="brand" href=".">
            程光曦微
            </a>
            <!-- Everything you want hidden at 940px or less, place within here -->
            <div class="nav-collapse collapse">
                <ul class="nav">
                    
                <li><a href="archive.html">归档</a>
                </li><li><a href="categories/index.html">标签</a>
                </li><li><a href="galleries/index.html">图集</a>
                </li><li><a href="galleries/index.html">关于作者</a>
                </li><li><a href="rss.xml">RSS</a>

                </li></ul>
                <ul class="nav pull-right">
                
                
                    <li>
                </ul>
            </div>
        </div>
    </div>
</div>
<!-- End of Menubar -->
<div class="container-fluid" id="container-fluid">
    <!--Body content-->
    <div class="row-fluid">
    <div class="span2"></div>
    <div class="span8">
    
        <div class="postbox">
        <h1><a href="posts/wxWidgets-Custom-UI.html">wxWidgets自定义绘图控件</a>
        <small>  
             发表于: <time class="published" datetime="2013-06-08T14:40:02">2013-06-08 14:40</time>
        </small></h1>
        <hr>
        <p>有时候系统提供的组件有可能不够你使用，比如我现在面临的显示YUV图像的控件，目前支持的功能是任意尺寸宏块或者CU的鼠标选定，鼠标拖拽确定范围，始终居中显示图片，鼠标滚轮翻页，ctrl加上滚轮放大或者缩小。</p>
<p>自定义wxControl第一步：</p>
<div class="code"><pre><span class="n">class</span> <span class="n">PicViewCtrl</span> <span class="o">:</span> <span class="n">public</span> <span class="n">wxControl</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">DECLARE_DYNAMIC_CLASS</span><span class="p">(</span><span class="n">PicViewCtrl</span><span class="p">);</span>
    <span class="c1">//….</span>
    <span class="n">DECLARE_EVENT_TABLE</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>


<p>显示YUV图像:</p>
<div class="code"><pre><span class="kt">void</span> <span class="n">PicViewCtrl</span><span class="o">::</span><span class="n">SetBitmap</span><span class="p">(</span><span class="n">wxBitmap</span> <span class="n">bitmap</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_bClearFlag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">m_cViewBitmap</span> <span class="o">=</span> <span class="n">bitmap</span><span class="p">;</span>
    <span class="n">m_CtrlSize</span><span class="p">.</span><span class="n">SetWidth</span><span class="p">(</span><span class="n">m_dScaleRate</span><span class="o">*</span><span class="n">m_cViewBitmap</span><span class="p">.</span><span class="n">GetWidth</span><span class="p">());</span>
    <span class="n">m_CtrlSize</span><span class="p">.</span><span class="n">SetHeight</span><span class="p">(</span><span class="n">m_dScaleRate</span><span class="o">*</span><span class="n">m_cViewBitmap</span><span class="p">.</span><span class="n">GetHeight</span><span class="p">());</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">SetSizeHints</span><span class="p">(</span><span class="n">m_CtrlSize</span><span class="p">);</span>
    <span class="n">GetParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">FitInside</span><span class="p">();</span>
    <span class="n">Refresh</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>重写OnPaint和OnEraseBkg</p>
<div class="code"><pre><span class="kt">void</span> <span class="n">PicViewCtrl</span><span class="o">::</span><span class="n">OnPaint</span><span class="p">(</span><span class="n">wxPaintEvent</span><span class="o">&amp;</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">wxPaintDC</span> <span class="n">dc</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
    <span class="n">Render</span><span class="p">(</span><span class="n">dc</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">PicViewCtrl</span><span class="o">::</span><span class="n">OnEraseBkg</span><span class="p">(</span><span class="n">wxEraseEvent</span><span class="o">&amp;</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">wxClientDC</span><span class="o">*</span> <span class="n">clientDC</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">.</span><span class="n">GetDC</span><span class="p">())</span>
        <span class="n">clientDC</span> <span class="o">=</span> <span class="n">new</span> <span class="n">wxClientDC</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
    <span class="n">wxDC</span><span class="o">*</span> <span class="n">pDC</span> <span class="o">=</span> <span class="n">clientDC</span> <span class="o">?</span> <span class="n">clientDC</span> <span class="o">:</span> <span class="n">event</span><span class="p">.</span><span class="n">GetDC</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">m_bClearFlag</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">pDC</span><span class="o">-&gt;</span><span class="n">Clear</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span>
        <span class="n">wxSize</span> <span class="n">size</span> <span class="o">=</span> <span class="n">GetClientSize</span><span class="p">();</span>
        <span class="n">wxString</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">s</span><span class="p">.</span><span class="n">Printf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"No picture to show!"</span><span class="p">),</span> <span class="n">size</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
        <span class="n">pDC</span><span class="o">-&gt;</span><span class="n">SetFont</span><span class="p">(</span><span class="o">*</span><span class="n">wxNORMAL_FONT</span><span class="p">);</span>
        <span class="n">pDC</span><span class="o">-&gt;</span><span class="n">GetTextExtent</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">w</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">height</span><span class="p">);</span>
        <span class="n">height</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="n">pDC</span><span class="o">-&gt;</span><span class="n">SetBrush</span><span class="p">(</span><span class="o">*</span><span class="n">wxTRANSPARENT_BRUSH</span><span class="p">);</span>
        <span class="n">pDC</span><span class="o">-&gt;</span><span class="n">SetPen</span><span class="p">(</span><span class="o">*</span><span class="n">wxLIGHT_GREY_PEN</span><span class="p">);</span>
        <span class="n">pDC</span><span class="o">-&gt;</span><span class="n">DrawLine</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
        <span class="n">pDC</span><span class="o">-&gt;</span><span class="n">DrawLine</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">pDC</span><span class="o">-&gt;</span><span class="n">DrawText</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">x</span><span class="o">-</span><span class="n">w</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">((</span><span class="n">size</span><span class="p">.</span><span class="n">y</span><span class="o">-</span><span class="p">(</span><span class="n">height</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">));</span>
        <span class="n">wxBitmap</span><span class="o">::</span><span class="n">CleanUpHandlers</span><span class="p">();</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">pDC</span><span class="o">-&gt;</span><span class="n">SetUserScale</span><span class="p">(</span><span class="n">m_dScaleRate</span><span class="p">,</span> <span class="n">m_dScaleRate</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">m_cViewBitmap</span><span class="p">.</span><span class="n">IsOk</span><span class="p">())</span>
        <span class="n">pDC</span><span class="o">-&gt;</span><span class="n">DrawBitmap</span><span class="p">(</span><span class="n">m_cViewBitmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">clientDC</span><span class="p">)</span>
        <span class="n">delete</span> <span class="n">clientDC</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Render负责画出选定的矩形方块</p>
<div class="code"><pre><span class="kt">void</span> <span class="n">PicViewCtrl</span><span class="o">::</span><span class="n">Render</span><span class="p">(</span><span class="n">wxDC</span><span class="o">&amp;</span> <span class="n">dc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">m_bClearFlag</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">dc</span><span class="p">.</span><span class="n">SetUserScale</span><span class="p">(</span><span class="n">m_dScaleRate</span><span class="p">,</span> <span class="n">m_dScaleRate</span><span class="p">);</span>
        <span class="n">dc</span><span class="p">.</span><span class="n">SetBrush</span><span class="p">(</span><span class="n">wxBrush</span><span class="p">(</span><span class="n">wxColor</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">128</span><span class="p">)));</span>
        <span class="n">dc</span><span class="p">.</span><span class="n">DrawRectangle</span><span class="p">(</span><span class="n">m_curLCUStart</span><span class="p">,</span> <span class="n">wxSize</span><span class="p">(</span><span class="n">m_curLCUEnd</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">m_curLCUStart</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">m_curLCUEnd</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">m_curLCUStart</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>在CSDN有关于MFC的两个函数的区别的讨论，现在摘录于下：</p>
<p>在MFC中任何一个window组件的绘图都是放在这两个member function中在设定上 OnEraseBkgnd()是用来画底图的而OnPaint()是用来画主要对象的</p>
<p>具体：<a href="http://bbs.csdn.net/topics/320086198">http://bbs.csdn.net/topics/320086198</a></p>
<p>ctrl加上滚轮放大或者缩小是使用了wxDC的SetUserScale，具体实现可以参考github中的<a href="https://github.com/XimingCheng/HEVCAnalyzer/blob/master/HEVCAnalyzer/PicViewCtrl.cpp">HEVCAnalyzer/PicViewCtrl.cpp</a></p>
<p>鼠标拖拽确定范围参考这里</p>
<p><a href="http://forums.wxwidgets.org/viewtopic.php?t=14575&amp;highlight=onmousemove">http://forums.wxwidgets.org/viewtopic.php?t=14575&amp;highlight=onmousemove</a></p>
<p>最终效果：</p>
<p><img alt="image" src="galleries/wxWidgets-Custom-UI/draw1.jpg"></p>
<p>其中的红色块会随着鼠标的移动而移动，默认设置是64x64大小，鼠标朝着蓝色方向拖动，滚轮会自动滚动，ctrl+滚轮放大缩小</p>
<p><img alt="image" src="galleries/wxWidgets-Custom-UI/draw2.jpg"></p>
<p>出现的问题：</p>
<p>The background color of the LCU rectangle is solid in Windows(画刷的alpha透明色在WIN32和GTK之下没有效果)，红色矩形应该是半透明的：</p>
<p><img alt="image" src="galleries/wxWidgets-Custom-UI/draw3.jpg"></p>
<p>Mac下面据说没有此问题，屌丝程序员，没有Mac机器测试。</p>
<p>WIN32后续解决方案：</p>
<p>The brush of the wxWidgets in Windows without GDIPlus enabled will not support the alpha channel, so rebuild the wxWidgets wxMSW with GDIPlus enabled is needed!</p>
            
        
    <p>
        <a href="posts/wxWidgets-Custom-UI.html#disqus_thread" data-disqus-identifier="cache\posts\wxWidgets-Custom-UI.html">Comments</a>


        </p></div>
        <div class="postbox">
        <h1><a href="posts/wxWidgets-UI.html">wxWidgets wxListCtrl与多线程UI更新</a>
        <small>  
             发表于: <time class="published" datetime="2013-05-31T20:10:06">2013-05-31 20:10</time>
        </small></h1>
        <hr>
        <p>很久没有编写GUI程序了，还是在本科的时候经常编写MFC程序，现在觉得作为一个IT人士，必须每隔上一段时间学习新的技术，否则会被淘汰。所以，我看了看wxWidgets这个号称跨平台的GUI库。</p>
<p>主要的目标是实现一个HEVC的码流分析器（<a href="https://github.com/XimingCheng/HEVCAnalyzer">HEVCAnalyzer</a>），这是一个长远的目标，估计要花上很长时间才能把功能完善，毕竟是我和一个同学在课余时间开发，而且目前遇到了很多的问题，我把这个星期我这方面遇到的问题总结一下，记录在此。</p>
<p>wxWidgets的使用我就不多说了，我的第一个目标就是编写一个YUV分析器，利用到了wxWidgets的AUI布局，下面是我的一个布局的草图：</p>
<p><img alt="image" src="galleries/wxWidgets-UI/design.jpg"></p>
<p>关于AUI布局，他是一个高级的布局管理，其中包含的属性Layers, Rows and Directions, Positions可以控制子窗口的位置，官方给了一个例子，效果如下（个别布局被我修改过）</p>
<p><img alt="image" src="galleries/wxWidgets-UI/demo.jpg"></p>
<p>所以我开始给我的项目程序设计了成了这个样子：</p>
<p><img alt="image" src="galleries/wxWidgets-UI/UI1.jpg"></p>
<p>其中左侧是YUV的缩率图列表使用了wxListCrtl，打开之后效果如下：</p>
<p><img alt="image" src="galleries/wxWidgets-UI/UI2.jpg"></p>
<p>其中这里使用了多线程更新UI，主要是因为如果YUV文件过大，打开处理时间过长，用户会感觉UI被卡死。使用线程控制UI更新，但是线程里面不能直接更新UI，目前是使用自定义消息发给父窗口，父窗口处理列表的更新：</p>
<p>启动线程：</p>
<div class="code"><pre><span class="k">if</span><span class="p">(</span><span class="n">m_pImage_list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">delete</span> <span class="n">m_pImage_list</span><span class="p">;</span>
    <span class="n">m_pImage_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">m_pImage_list</span> <span class="o">=</span> <span class="n">new</span> <span class="n">wxImageList</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">m_iSourceWidth</span><span class="o">*</span><span class="n">scaleRate</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">m_iSourceHeight</span><span class="o">*</span><span class="n">scaleRate</span><span class="p">);</span>
<span class="n">m_pThumbnalList</span><span class="o">-&gt;</span><span class="n">SetImageList</span><span class="p">(</span><span class="n">m_pImage_list</span><span class="p">,</span> <span class="n">wxIMAGE_LIST_NORMAL</span><span class="p">);</span>
<span class="n">m_pThumbThread</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ThumbnailThread</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">m_pImage_list</span><span class="p">,</span> <span class="n">m_iSourceWidth</span><span class="p">,</span> <span class="n">m_iSourceHeight</span><span class="p">,</span> <span class="n">bit</span><span class="p">,</span> <span class="n">sfile</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">m_pThumbThread</span><span class="o">-&gt;</span><span class="n">Create</span><span class="p">()</span> <span class="o">!=</span> <span class="n">wxTHREAD_NO_ERROR</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">wxLogError</span><span class="p">(</span><span class="n">wxT</span><span class="p">(</span><span class="s">"Can't create the thread!"</span><span class="p">));</span>
    <span class="n">delete</span> <span class="n">m_pThumbThread</span><span class="p">;</span>
    <span class="n">m_pThumbThread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">m_pThumbThread</span><span class="o">-&gt;</span><span class="n">Run</span><span class="p">()</span> <span class="o">!=</span> <span class="n">wxTHREAD_NO_ERROR</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">wxLogError</span><span class="p">(</span><span class="n">wxT</span><span class="p">(</span><span class="s">"Can't create the thread!"</span><span class="p">));</span>
        <span class="n">delete</span> <span class="n">m_pThumbThread</span><span class="p">;</span>
        <span class="n">m_pThumbThread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>线程中处理YUV to RGB转换：</p>
<div class="code"><pre><span class="kt">void</span><span class="o">*</span> <span class="n">ThumbnailThread</span><span class="o">::</span><span class="n">Entry</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_pImageList</span><span class="o">-&gt;</span><span class="n">RemoveAll</span><span class="p">();</span>
    <span class="n">TVideoIOYuv</span> <span class="n">cYUVIO</span><span class="p">;</span>
    <span class="n">cYUVIO</span><span class="p">.</span><span class="n">open</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">m_sYUVPath</span><span class="p">.</span><span class="n">mb_str</span><span class="p">(</span><span class="n">wxConvUTF8</span><span class="p">).</span><span class="n">data</span><span class="p">(),</span> <span class="nb">false</span><span class="p">,</span> <span class="n">m_iYUVBit</span><span class="p">,</span> <span class="n">m_iYUVBit</span><span class="p">,</span> <span class="n">m_iYUVBit</span><span class="p">,</span> <span class="n">m_iYUVBit</span><span class="p">);</span>
    <span class="n">TComPicYuv</span><span class="o">*</span> <span class="n">pcPicYuvOrg</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TComPicYuv</span><span class="p">;</span>
    <span class="n">pcPicYuvOrg</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">(</span> <span class="n">m_iSourceWidth</span><span class="p">,</span> <span class="n">m_iSourceHeight</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>

    <span class="n">wxBitmap</span> <span class="nf">bmp</span><span class="p">(</span><span class="n">m_iSourceWidth</span><span class="p">,</span> <span class="n">m_iSourceHeight</span><span class="p">,</span> <span class="mi">24</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">frame</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">cYUVIO</span><span class="p">.</span><span class="n">isEof</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">TestDestroy</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pad</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
        <span class="n">cYUVIO</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">pcPicYuvOrg</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>
        <span class="n">wxNativePixelData</span> <span class="nf">img</span><span class="p">(</span><span class="n">bmp</span><span class="p">);</span>
        <span class="n">wxNativePixelData</span><span class="o">::</span><span class="n">Iterator</span> <span class="n">p</span><span class="p">(</span><span class="n">img</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m_iSourceHeight</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">wxNativePixelData</span><span class="o">::</span><span class="n">Iterator</span> <span class="n">rowStart</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
            <span class="n">Pel</span><span class="o">*</span> <span class="n">pY</span> <span class="o">=</span> <span class="n">pcPicYuvOrg</span><span class="o">-&gt;</span><span class="n">getLumaAddr</span><span class="p">()</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="n">pcPicYuvOrg</span><span class="o">-&gt;</span><span class="n">getStride</span><span class="p">();</span>
            <span class="n">Pel</span><span class="o">*</span> <span class="n">pU</span> <span class="o">=</span> <span class="n">pcPicYuvOrg</span><span class="o">-&gt;</span><span class="n">getCbAddr</span><span class="p">()</span>   <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">pcPicYuvOrg</span><span class="o">-&gt;</span><span class="n">getCStride</span><span class="p">();</span>
            <span class="n">Pel</span><span class="o">*</span> <span class="n">pV</span> <span class="o">=</span> <span class="n">pcPicYuvOrg</span><span class="o">-&gt;</span><span class="n">getCrAddr</span><span class="p">()</span>   <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">pcPicYuvOrg</span><span class="o">-&gt;</span><span class="n">getCStride</span><span class="p">();</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_iSourceWidth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// YUV to RBG转换</span>
                <span class="c1">//此处省略, 具体可以参见Github项目中详细处理</span>
            <span class="p">}</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">rowStart</span><span class="p">;</span>
            <span class="n">p</span><span class="p">.</span><span class="n">OffsetY</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//bmp.SaveFile(_("test.bmp"), wxBITMAP_TYPE_BMP);</span>
        <span class="n">wxImage</span> <span class="n">bimg</span> <span class="o">=</span> <span class="n">bmp</span><span class="p">.</span><span class="n">ConvertToImage</span><span class="p">();</span>
        <span class="kt">double</span> <span class="n">scaleRate</span> <span class="o">=</span> <span class="mf">165.0</span><span class="o">/</span><span class="n">m_iSourceWidth</span><span class="p">;</span>
        <span class="n">wxImage</span> <span class="n">simg</span> <span class="o">=</span> <span class="n">bimg</span><span class="p">.</span><span class="n">Scale</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">m_iSourceWidth</span><span class="o">*</span><span class="n">scaleRate</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">m_iSourceHeight</span><span class="o">*</span><span class="n">scaleRate</span><span class="p">);</span>
        <span class="n">wxBitmap</span> <span class="nf">newbmp</span><span class="p">(</span><span class="n">simg</span><span class="p">);</span>
        <span class="n">m_pImageList</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">newbmp</span><span class="p">);</span>
        <span class="n">wxCommandEvent</span> <span class="nf">event</span><span class="p">(</span><span class="n">wxEVT_ADDANIMAGE_THREAD</span><span class="p">,</span> <span class="n">wxID_ANY</span><span class="p">);</span>
        <span class="n">event</span><span class="p">.</span><span class="n">SetInt</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
        <span class="c1">//m_pFrame-&gt;ProcessEvent(event);</span>
        <span class="c1">// this method can be used in Linux</span>
        <span class="n">wxPostEvent</span><span class="p">(</span><span class="n">m_pFrame</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
        <span class="n">frame</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pcPicYuvOrg</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">();</span>
    <span class="n">delete</span> <span class="n">pcPicYuvOrg</span><span class="p">;</span>
    <span class="n">pcPicYuvOrg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">wxCommandEvent</span> <span class="nf">event</span><span class="p">(</span><span class="n">wxEVT_END_THREAD</span><span class="p">,</span> <span class="n">wxID_ANY</span><span class="p">);</span>
    <span class="n">wxPostEvent</span><span class="p">(</span><span class="n">m_pFrame</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">wxThread</span><span class="o">::</span><span class="n">ExitCode</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>自定义消息处理函数（父窗口）：</p>
<div class="code"><pre><span class="kt">void</span> <span class="n">MainFrame</span><span class="o">::</span><span class="n">OnThreadAddImage</span><span class="p">(</span><span class="n">wxCommandEvent</span><span class="o">&amp;</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">event</span><span class="p">.</span><span class="n">GetInt</span><span class="p">();</span>
<span class="c1">//    wxString str;</span>
<span class="c1">//    str.Printf(wxT("frame %d added"), frame);</span>
<span class="c1">//    wxMessageBox(str);</span>
    <span class="n">wxListItem</span> <span class="n">item</span><span class="p">;</span>
    <span class="n">item</span><span class="p">.</span><span class="n">SetId</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
    <span class="n">wxString</span> <span class="n">text</span><span class="p">;</span>
    <span class="n">text</span><span class="p">.</span><span class="n">Printf</span><span class="p">(</span><span class="n">wxT</span><span class="p">(</span><span class="s">"POC %d"</span><span class="p">),</span> <span class="n">frame</span><span class="p">);</span>
    <span class="n">item</span><span class="p">.</span><span class="n">SetText</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
    <span class="n">item</span><span class="p">.</span><span class="n">SetImage</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
    <span class="n">m_pThumbnalList</span><span class="o">-&gt;</span><span class="n">InsertItem</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>遇到的问题:</p>
<p>1 Linux的wxThread估计有问题 ，无法启动线程</p>
<p><img alt="image" src="galleries/wxWidgets-UI/crash.jpg"></p>
<p>解决方法：</p>
<p>在wxApp的子类的构造函数添加线程初始化函数 XInitThreads();</p>
<div class="code"><pre><span class="n">class</span> <span class="n">HEVCodecApp</span> <span class="o">:</span> <span class="n">public</span> <span class="n">wxApp</span>
<span class="p">{</span>
<span class="nl">public:</span>
<span class="cp">#if defined(__UNIX__)</span>
    <span class="n">HEVCodecApp</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">XInitThreads</span><span class="p">();</span>
    <span class="p">}</span>
<span class="cp">#endif</span>
    <span class="kt">bool</span> <span class="n">OnInit</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>


<p>参考 <a href="http://forums.wxwidgets.org/viewtopic.php?t=32346&amp;p=139431">http://forums.wxwidgets.org/viewtopic.php?t=32346&amp;p=139431</a></p>
<p>2 wxListCtrl在Linux下面显示有问题，无法单列显示列表，这个是wxWidgets 2.8.12的bug，其例子也有这个bug：</p>
<p><img alt="image" src="galleries/wxWidgets-UI/bug.jpg"></p>
<p>我们打算使用wxHTMLListBox来解决这个bug</p>
            
        
    <p>
        <a href="posts/wxWidgets-UI.html#disqus_thread" data-disqus-identifier="cache\posts\wxWidgets-UI.html">Comments</a>


        </p></div>
        <div class="postbox">
        <h1><a href="posts/HEVC-basic-CU-learning.html">HEVC学习之CU划分小实验</a>
        <small>  
             发表于: <time class="published" datetime="2012-12-16T20:36:15">2012-12-16 20:36</time>
        </small></h1>
        <hr>
        <p>HEVC的CU的概念相信每个搞HEVC的童鞋都很清楚，但是怎么才能让HEVC的CU划分更加直观的表现出来呢，每次调试程序我的心中都有着下面这幅图，可是，我想把它直观的表现出来！谁叫咱智商不行，还是个没有用的程序猿，以后也毕不了业，也找不到工作呢！</p>
<p><img alt="image" src="galleries/HEVC-CU/cu.jpg"></p>
<p>好了，废话不多说，咱们不搞理论的，没有太多废话！基于HM 9.0</p>
<p>要想实际的打出CU划分的最终结果，我想了一个办法，就是修改HEVC的decoder，在CU最终划分的结果的地方把像素换成一个特殊值，比如luma改成0，就变成黑色的了。</p>
<p>怎么改呢，我代码才看了没多久，只好先研究一下decoder：</p>
<p>作为屌丝程序员，上来俺就找decoder的main函数，俺知道main函数里面这句话是关键：</p>
<div class="code"><pre><span class="c1">// call decoding function</span>
<span class="n">cTAppDecTop</span><span class="p">.</span><span class="n">decode</span><span class="p">();</span>
</pre></div>


<p>不多说，进去，在TAppDecTop::decode()函数里面俺知道这一句也是关键：</p>
<div class="code"><pre><span class="n">bNewPicture</span> <span class="o">=</span> <span class="n">m_cTDecTop</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="n">nalu</span><span class="p">,</span> <span class="n">m_iSkipFrame</span><span class="p">,</span> <span class="n">m_iPOCLastDisplay</span><span class="p">);</span>
</pre></div>


<p>不多说，进去，然后就豁然了一下，下面是一个对nalu.m_nalUnitType switch的语句，是对不同的nal分别解码，我要管的不是pps也不是sps就直接看解码一个slice：</p>
<div class="code"><pre><span class="k">return</span> <span class="nf">xDecodeSlice</span><span class="p">(</span><span class="n">nalu</span><span class="p">,</span> <span class="n">iSkipFrame</span><span class="p">,</span> <span class="n">iPOCLastDisplay</span><span class="p">);</span>
</pre></div>


<p>xDecodeSlice这个函数比较长，不过我就看上了一句话，这个函数的结尾部分：</p>
<div class="code"><pre><span class="c1">//  Decode a picture</span>
<span class="n">m_cGopDecoder</span><span class="p">.</span><span class="n">decompressSlice</span><span class="p">(</span><span class="n">nalu</span><span class="p">.</span><span class="n">m_Bitstream</span><span class="p">,</span> <span class="n">pcPic</span><span class="p">);</span>
</pre></div>


<p>TDecGop::decompressSlice(TComInputBitstream<em>pcBitstream, TComPic</em>&amp; rpcPic)这个函数俺也就看上一句话：</p>
<div class="code"><pre><span class="n">m_pcSliceDecoder</span><span class="o">-&gt;</span><span class="n">decompressSlice</span><span class="p">(</span> <span class="n">pcBitstream</span><span class="p">,</span> <span class="n">ppcSubstreams</span><span class="p">,</span> <span class="n">rpcPic</span><span class="p">,</span> <span class="n">m_pcSbacDecoder</span><span class="p">,</span> <span class="n">m_pcSbacDecoders</span><span class="p">);</span>
</pre></div>


<p>这个函数很关键，里面有这样的一个大循环：</p>
<div class="code"><pre><span class="k">for</span><span class="p">(</span> <span class="n">Int</span> <span class="n">iCUAddr</span> <span class="o">=</span> <span class="n">iStartCUAddr</span><span class="p">;</span> <span class="o">!</span><span class="n">uiIsLast</span> <span class="o">&amp;&amp;</span> <span class="n">iCUAddr</span> <span class="o">&lt;</span> <span class="n">rpcPic</span><span class="o">-&gt;</span><span class="n">getNumCUsInFrame</span><span class="p">();</span> <span class="n">iCUAddr</span> <span class="o">=</span> <span class="n">rpcPic</span><span class="o">-&gt;</span><span class="n">getPicSym</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">xCalculateNxtCUAddr</span><span class="p">(</span><span class="n">iCUAddr</span><span class="p">)</span> <span class="p">)</span>
  <span class="p">{</span><span class="cm">/*循环里面的代码*/</span><span class="p">}</span>
</pre></div>


<p>看到这个地方你想到了啥呢，没错，这是对LCU一个个循环的地方，在这个循环里面调用了m_pcCuDecoder-&gt;decodeCU( pcCU, uiIsLast ); decodeCU就是对一个LCU进行解码，到decodeCU里面看一看，发现他调用了xDecodeCU，而xDecodeCU是一个递归函数，是分别解码各个最终划分的CU，xDecodeCU里面有一个是否要一分为四的判断：</p>
<div class="code"><pre><span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="p">(</span> <span class="n">uiDepth</span> <span class="o">&lt;</span> <span class="n">pcCU</span><span class="o">-&gt;</span><span class="n">getDepth</span><span class="p">(</span> <span class="n">uiAbsPartIdx</span> <span class="p">)</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">uiDepth</span> <span class="o">&lt;</span> <span class="n">g_uiMaxCUDepth</span> <span class="o">-</span> <span class="n">g_uiAddCUDepth</span> <span class="p">)</span> <span class="p">)</span> <span class="o">||</span> <span class="n">bBoundary</span> <span class="p">)</span>
</pre></div>


<p>如果条件不满足，不就说明到达最终的CU的划分的地方了吗，好，在if出来的地方填上这样的一句话：</p>
<div class="code"><pre><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"uiLPelX uiTPelY uiRPelX uiBPelY "</span><span class="o">&lt;&lt;</span><span class="n">uiLPelX</span><span class="o">&lt;&lt;</span><span class="s">" "</span><span class="o">&lt;&lt;</span><span class="n">uiTPelY</span><span class="o">&lt;&lt;</span><span class="s">" "</span><span class="o">&lt;&lt;</span><span class="n">uiRPelX</span><span class="o">&lt;&lt;</span><span class="s">" "</span><span class="o">&lt;&lt;</span><span class="n">uiBPelY</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>


<p>运行解码器，解码一个I帧，输出的部分结果如下：</p>
<div class="code"><pre><span class="n">uiLPelX</span> <span class="n">uiTPelY</span> <span class="n">uiRPelX</span> <span class="n">uiBPelY</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">15</span> <span class="mi">15</span>
<span class="n">uiLPelX</span> <span class="n">uiTPelY</span> <span class="n">uiRPelX</span> <span class="n">uiBPelY</span> <span class="mi">16</span> <span class="mi">0</span> <span class="mi">31</span> <span class="mi">15</span>
<span class="n">uiLPelX</span> <span class="n">uiTPelY</span> <span class="n">uiRPelX</span> <span class="n">uiBPelY</span> <span class="mi">0</span> <span class="mi">16</span> <span class="mi">15</span> <span class="mi">31</span>
<span class="n">uiLPelX</span> <span class="n">uiTPelY</span> <span class="n">uiRPelX</span> <span class="n">uiBPelY</span> <span class="mi">16</span> <span class="mi">16</span> <span class="mi">31</span> <span class="mi">31</span>
<span class="n">uiLPelX</span> <span class="n">uiTPelY</span> <span class="n">uiRPelX</span> <span class="n">uiBPelY</span> <span class="mi">32</span> <span class="mi">0</span> <span class="mi">63</span> <span class="mi">31</span>
<span class="n">uiLPelX</span> <span class="n">uiTPelY</span> <span class="n">uiRPelX</span> <span class="n">uiBPelY</span> <span class="mi">0</span> <span class="mi">32</span> <span class="mi">15</span> <span class="mi">47</span>
<span class="n">uiLPelX</span> <span class="n">uiTPelY</span> <span class="n">uiRPelX</span> <span class="n">uiBPelY</span> <span class="mi">16</span> <span class="mi">32</span> <span class="mi">31</span> <span class="mi">47</span>
<span class="n">uiLPelX</span> <span class="n">uiTPelY</span> <span class="n">uiRPelX</span> <span class="n">uiBPelY</span> <span class="mi">0</span> <span class="mi">48</span> <span class="mi">15</span> <span class="mi">63</span>
<span class="n">uiLPelX</span> <span class="n">uiTPelY</span> <span class="n">uiRPelX</span> <span class="n">uiBPelY</span> <span class="mi">16</span> <span class="mi">48</span> <span class="mi">31</span> <span class="mi">63</span>
<span class="n">uiLPelX</span> <span class="n">uiTPelY</span> <span class="n">uiRPelX</span> <span class="n">uiBPelY</span> <span class="mi">32</span> <span class="mi">32</span> <span class="mi">63</span> <span class="mi">63</span>
</pre></div>


<p>可以明显看出这一个CU的划分是如下结果：</p>
<p><img alt="image" src="galleries/HEVC-CU/LCU1.jpg"></p>
<p>于是我就想个办法把每个小块的的两个坐标点存下来不就好了吗，于是在typedef.h我添加了如下代码：</p>
<div class="code"><pre><span class="c1">//cheng </span>
<span class="k">struct</span> <span class="n">PtPair</span>
<span class="p">{</span>
  <span class="n">UInt</span> <span class="n">_pt1x</span><span class="p">;</span>
  <span class="n">UInt</span> <span class="n">_pt1y</span><span class="p">;</span>
  <span class="n">UInt</span> <span class="n">_pt2x</span><span class="p">;</span>
  <span class="n">UInt</span> <span class="n">_pt2y</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>定义一个struct，保存一组坐标。在class TDecSlice里面添加一个私有成员：</p>
<div class="code"><pre><span class="nx">std</span><span class="p">::</span><span class="nl">vector</span><span class="o">&lt;</span><span class="nx">PtPair</span><span class="o">&gt;</span> <span class="nx">m_listLastCU</span>
</pre></div>


<p>用来保存一个slice里面所有的最终CU的划分结果</p>
<p>修改TDecCu::decodeCU的函数参数，把在class TDecSlice里面的m_listLastCU传递过去：</p>
<div class="code"><pre><span class="bp">Void</span> <span class="nx">TDecCu</span><span class="p">::</span><span class="nl">decodeCU</span><span class="p">(</span> <span class="nx">TComDataCU</span><span class="o">*</span> <span class="nx">pcCU</span><span class="p">,</span> <span class="nx">UInt</span><span class="o">&amp;</span> <span class="nx">ruiIsLast</span><span class="p">,</span> <span class="nx">std</span><span class="p">::</span><span class="nl">vector</span><span class="o">&lt;</span><span class="nx">PtPair</span><span class="o">&gt;&amp;</span> <span class="nb">list</span> <span class="p">)</span>
</pre></div>


<p>调用改为：</p>
<div class="code"><pre><span class="n">m_pcCuDecoder</span><span class="o">-&gt;</span><span class="n">decodeCU</span>     <span class="p">(</span> <span class="n">pcCU</span><span class="p">,</span> <span class="n">uiIsLast</span><span class="p">,</span> <span class="n">m_listLastCU</span> <span class="p">);</span>
</pre></div>


<p>classTDecCu也添加一个私有成员用来保存class TDecSlice传递过来的vector的指针：</p>
<div class="code"><pre><span class="nx">std</span><span class="p">::</span><span class="nl">vector</span><span class="o">&lt;</span><span class="nx">PtPair</span><span class="o">&gt;*</span> <span class="nx">m_plistPt</span><span class="p">;</span>
</pre></div>


<p>Void TDecCu::decodeCU( TComDataCU* pcCU,UInt&amp; ruiIsLast, std::vector<ptpair>&amp; list )函数里面开头部分添加：</ptpair></p>
<div class="code"><pre><span class="n">m_plistPt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">;</span>
</pre></div>


<p>decodeCU函数变成如下结果：</p>
<div class="code"><pre><span class="bp">Void</span> <span class="nx">TDecCu</span><span class="p">::</span><span class="nl">decodeCU</span><span class="p">(</span> <span class="nx">TComDataCU</span><span class="o">*</span> <span class="nx">pcCU</span><span class="p">,</span> <span class="nx">UInt</span><span class="o">&amp;</span> <span class="nx">ruiIsLast</span><span class="p">,</span> <span class="nx">std</span><span class="p">::</span><span class="nl">vector</span><span class="o">&lt;</span><span class="nx">PtPair</span><span class="o">&gt;&amp;</span> <span class="nb">list</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//cheng</span>
  <span class="n">m_plistPt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nb">list</span><span class="p">;</span>
  <span class="c1">//</span>
  <span class="k">if</span> <span class="p">(</span> <span class="nx">pcCU</span><span class="o">-&gt;</span><span class="nx">getSlice</span><span class="p">()</span><span class="o">-&gt;</span><span class="nx">getPPS</span><span class="p">()</span><span class="o">-&gt;</span><span class="nx">getUseDQP</span><span class="p">()</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="nx">setdQPFlag</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
  <span class="p">}</span>

<span class="vi">#if</span> <span class="o">!</span><span class="nx">REMOVE_BURST_IPCM</span>
  <span class="nx">pcCU</span><span class="o">-&gt;</span><span class="nx">setNumSucIPCM</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="vi">#endif</span>

  <span class="c1">// start from the top level CU</span>
  <span class="nx">xDecodeCU</span><span class="p">(</span> <span class="nx">pcCU</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">ruiIsLast</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>在TDecCu::xDecodeCU( TComDataCU* pcCU, UInt uiAbsPartIdx, UIntuiDepth, UInt&amp; ruiIsLast)这个函数里面的打印坐标信息的那一句话后面添加上：</p>
<div class="code"><pre>  <span class="n">pt</span><span class="p">.</span><span class="n">_pt1x</span> <span class="o">=</span> <span class="n">uiLPelX</span><span class="p">;</span> <span class="n">pt</span><span class="p">.</span><span class="n">_pt1y</span> <span class="o">=</span> <span class="n">uiTPelY</span><span class="p">;</span> <span class="n">pt</span><span class="p">.</span><span class="n">_pt2x</span> <span class="o">=</span> <span class="n">uiRPelX</span><span class="p">;</span> <span class="n">pt</span><span class="p">.</span><span class="n">_pt2y</span> <span class="o">=</span> <span class="n">uiBPelY</span><span class="p">;</span>
  <span class="n">m_plistPt</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">pt</span><span class="p">);</span>
</pre></div>


<p>这样的话，解码完一帧，m_listLastCU里面就保存了CU最终划分的结果。</p>
<p>TDecSlice::decompressSlice开头需要把vector清空以便于在解码下一帧的时候vector中的信息要重新记录</p>
<div class="code"><pre><span class="n">m_listLastCU</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</pre></div>


<p>最后在TDecSlice::decompressSlice的LCU的for循环的后面添加绘制CU最终边框的代码：</p>
<div class="code"><pre>  <span class="n">Pel</span><span class="o">*</span> <span class="n">pY</span> <span class="o">=</span> <span class="n">rpcPic</span><span class="o">-&gt;</span><span class="n">getPicYuvRec</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getLumaAddr</span><span class="p">();</span>
  <span class="n">UInt</span> <span class="n">stride</span> <span class="o">=</span> <span class="n">rpcPic</span><span class="o">-&gt;</span><span class="n">getPicYuvRec</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getStride</span><span class="p">();</span>
  <span class="k">for</span><span class="p">(</span><span class="n">UInt</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">m_listLastCU</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="n">UInt</span> <span class="n">y</span> <span class="o">=</span> <span class="n">m_listLastCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt1y</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">m_listLastCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt2y</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">for</span><span class="p">(</span><span class="n">UInt</span> <span class="n">x</span> <span class="o">=</span> <span class="n">m_listLastCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt1x</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">m_listLastCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt2x</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">m_listLastCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt1y</span> <span class="cm">/*|| y == m_listSCU[index]._pt2y*/</span><span class="p">)</span>
          <span class="n">pY</span><span class="p">[</span><span class="n">y</span><span class="o">*</span><span class="n">stride</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">m_listLastCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt1x</span> <span class="cm">/*|| x == m_listSCU[index]._pt2x*/</span><span class="p">)</span>
          <span class="n">pY</span><span class="p">[</span><span class="n">y</span><span class="o">*</span><span class="n">stride</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>


<p>解码一帧图像使用YUV播放器查看效果：</p>
<p><img alt="image" src="galleries/HEVC-CU/result1.jpg"></p>
<p>怎么办呢，在TDecSlice::decompressSlice函数里面添加一个类似的vector记录一下LCU，在class TDecSlice里面再添加一个私有成员std::vector<ptpair>m_listLCU;，TDecSlice::decompressSlice函数开始的地方清空vector：m_listLastCU.clear();</ptpair></p>
<p>在LCU的大大的for循环里面添加代码记录LCU划分的信息：</p>
<div class="code"><pre><span class="n">UInt</span> <span class="n">xpel</span> <span class="o">=</span> <span class="n">pcCU</span><span class="o">-&gt;</span><span class="n">getCUPelX</span><span class="p">();</span>
<span class="n">UInt</span> <span class="n">ypel</span> <span class="o">=</span> <span class="n">pcCU</span><span class="o">-&gt;</span><span class="n">getCUPelY</span><span class="p">();</span>
<span class="n">UInt</span> <span class="n">width</span> <span class="o">=</span> <span class="n">pcCU</span><span class="o">-&gt;</span><span class="n">getWidth</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">UInt</span> <span class="n">height</span> <span class="o">=</span> <span class="n">pcCU</span><span class="o">-&gt;</span><span class="n">getHeight</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">//std::cout&lt;&lt;"xpel :"&lt;&lt;xpel&lt;&lt;"ypel :"&lt;&lt;ypel&lt;&lt;"width : "&lt;&lt;width&lt;&lt;"height :"&lt;&lt;height&lt;&lt;std::endl;</span>
<span class="n">PtPair</span> <span class="n">pt</span><span class="p">;</span>
<span class="n">pt</span><span class="p">.</span><span class="n">_pt1x</span> <span class="o">=</span> <span class="n">xpel</span><span class="p">;</span> <span class="n">pt</span><span class="p">.</span><span class="n">_pt1y</span> <span class="o">=</span> <span class="n">ypel</span><span class="p">;</span> <span class="n">pt</span><span class="p">.</span><span class="n">_pt2x</span> <span class="o">=</span> <span class="n">xpel</span> <span class="o">+</span> <span class="n">width</span><span class="p">;</span> <span class="n">pt</span><span class="p">.</span><span class="n">_pt2y</span> <span class="o">=</span> <span class="n">ypel</span> <span class="o">+</span> <span class="n">height</span><span class="p">;</span>
<span class="n">m_listLCU</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pt</span><span class="p">);</span>
</pre></div>


<p>然后在刚才的画黑框的代码后面添加LCU的画白框的代码：</p>
<div class="code"><pre>  <span class="k">for</span><span class="p">(</span><span class="n">UInt</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">m_listLCU</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="n">UInt</span> <span class="n">y</span> <span class="o">=</span> <span class="n">m_listLCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt1y</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">m_listLCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt2y</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">for</span><span class="p">(</span><span class="n">UInt</span> <span class="n">x</span> <span class="o">=</span> <span class="n">m_listLCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt1x</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">m_listLCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt2x</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">m_listLCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt1y</span> <span class="cm">/*|| y == m_listLCU[index]._pt2y*/</span><span class="p">)</span>
          <span class="n">pY</span><span class="p">[</span><span class="n">y</span><span class="o">*</span><span class="n">stride</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">m_listLCU</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">_pt1x</span> <span class="cm">/*|| x == m_listLCU[index]._pt2x*/</span><span class="p">)</span>
          <span class="n">pY</span><span class="p">[</span><span class="n">y</span><span class="o">*</span><span class="n">stride</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>


<p>运行解码器再试一下：</p>
<p><img alt="image" src="galleries/HEVC-CU/result2.jpg"></p>
<p>你可以很明显的看到LCU的大白色块！哈哈！</p>
<p>后面其实你可以发现：</p>
<p><img alt="image" src="galleries/HEVC-CU/LCU1.jpg"></p>
<p>和这个一模一样</p>
<p><img alt="image" src="galleries/HEVC-CU/LCU2.jpg"></p>
<p>注：以上画框的结果只能适用于I帧，对于P/B帧，由于解码我修改重建值也就修改了了P/B参考帧的像素值，导致P/B帧画框会出现一定混乱，不过对于P/B帧，vector里面存放的数据应该是对的！</p>
            
        
    <p>
        <a href="posts/HEVC-basic-CU-learning.html#disqus_thread" data-disqus-identifier="cache\posts\HEVC-basic-CU-learning.html">Comments</a>


        </p></div>
        <div class="postbox">
        <h1><a href="posts/oh-memory-leak.html">内存泄露，我擦</a>
        <small>  
             发表于: <time class="published" datetime="2012-11-18T00:31:01">2012-11-18 00:31</time>
        </small></h1>
        <hr>
        <!-- 
.. link: 
.. description: 
.. tags: 内存泄露,C++,VisualLeak Detector,valgrind
.. date: 2012/11/18 00:31:01
.. title: 内存泄露，我擦
.. slug: oh-memory-leak
-->

<p>在这个快节奏的环境下，男人怕泄，女人怕漏。一个C/C++程序猿怕啥呢——泄露。下面是我从别的地方摘录的一段[1]。</p>
<p>“C/C++编译的程序的内存分配分为以下几个部分：栈区（stack）——由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆区（heap）——一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。全局区（静态区）（static）——全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。文字常量区——常量字符串就是放在这里的，程序结束后由系统释放。程序代码区——存放函数体的二进制代码。”</p>
<p>Memory Leak中文翻译为内存泄露，这是一个令人头疼的话题，因为由程序猿手动动态分配的内存一般都在heap上，这个蛋疼的东西总困扰着C/C++程序猿，如果不手动释放该内存，在程序退出之前，这一块内存是不会被释放的。</p>
<p>有人这时候就站出来了，你怎么能这么懒呢，用完释放不就得了吗。我只能说，“猿”非圣贤，咋就不能有个疏忽的地方呢。一旦疏忽就悲剧了，代码逻辑简单的还好，一旦复杂起来，恐怕只有上帝才知道是哪个地方泄露了。都这样了，当然咱们不多说废话了，我来介绍两个专搞内存泄露的工具。</p>
<p>Windows工具——VisualLeak Detector(VLD)，这货是用在Visual Studio上面的，至于如果你使用MingW之类的我还木有研究过。官方网站是：<a href="http://vld.codeplex.com/" title="http://vld.codeplex.com/">VisualLeak Detector(VLD)</a></p>
<p>下载下来，安装，把安装目录下面的src目录添加到VisualStudio的include path里面，把lib目录添加到Visual Studio的lib path里面，注意有lib目录有两个分别代表的是x86和x64，这要根据你的工程的配置来选择使用哪一个。好了一切就绪了，我们试一把。</p>
<p>首先编写一个非常简单的泄露程序，虽然我在一些面试题目上面看到说这个不算内存泄露。</p>
<div class="code"><pre><span class="vi">#include</span> <span class="o">&lt;</span><span class="nx">iostream</span><span class="o">&gt;</span>

<span class="nx">int</span> <span class="nx">main</span><span class="p">(</span><span class="nx">int</span> <span class="nx">argc</span><span class="p">,</span> <span class="nx">char</span><span class="o">**</span> <span class="nx">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nx">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">new</span> <span class="nx">int</span><span class="err">[</span><span class="mi">10</span><span class="cp">]</span>;
    return 0;
}
</pre></div>


<p>使用F5直接调试运行一下，观察output的最后一段：</p>
<div class="code"><pre><span class="n">WARNING</span><span class="o">:</span> <span class="n">Visual</span> <span class="n">Leak</span> <span class="n">Detector</span> <span class="n">detected</span> <span class="n">memory</span> <span class="n">leaks</span><span class="o">!</span>
<span class="o">----------</span> <span class="n">Block</span> <span class="mi">1</span> <span class="n">at</span> <span class="mh">0x00379580</span><span class="o">:</span> <span class="mi">40</span> <span class="n">bytes</span> <span class="o">----------</span>
  <span class="n">Call</span> <span class="n">Stack</span><span class="o">:</span>
    <span class="n">e</span><span class="o">:\</span><span class="n">projects</span><span class="o">\</span><span class="n">leak</span><span class="o">\</span><span class="n">leak</span><span class="o">\</span><span class="n">source</span><span class="o">.</span><span class="na">cpp</span> <span class="o">(</span><span class="mi">6</span><span class="o">):</span> <span class="n">leak</span><span class="o">.</span><span class="na">exe</span><span class="o">!</span><span class="n">main</span> <span class="o">+</span> <span class="mh">0x7</span> <span class="n">bytes</span>
    <span class="n">f</span><span class="o">:\</span><span class="n">dd</span><span class="o">\</span><span class="n">vctools</span><span class="o">\</span><span class="n">crt_bld</span><span class="o">\</span><span class="n">self_x86</span><span class="o">\</span><span class="n">crt</span><span class="o">\</span><span class="n">src</span><span class="o">\</span><span class="n">crtexe</span><span class="o">.</span><span class="na">c</span> <span class="o">(</span><span class="mi">536</span><span class="o">):</span> <span class="n">leak</span><span class="o">.</span><span class="na">exe</span><span class="o">!</span><span class="n">__tmainCRTStartup</span> <span class="o">+</span> <span class="mh">0x19</span> <span class="n">bytes</span>
    <span class="n">f</span><span class="o">:\</span><span class="n">dd</span><span class="o">\</span><span class="n">vctools</span><span class="o">\</span><span class="n">crt_bld</span><span class="o">\</span><span class="n">self_x86</span><span class="o">\</span><span class="n">crt</span><span class="o">\</span><span class="n">src</span><span class="o">\</span><span class="n">crtexe</span><span class="o">.</span><span class="na">c</span> <span class="o">(</span><span class="mi">377</span><span class="o">):</span> <span class="n">leak</span><span class="o">.</span><span class="na">exe</span><span class="o">!</span><span class="n">mainCRTStartup</span>
    <span class="mh">0x765</span><span class="n">CED6C</span> <span class="o">(</span><span class="n">File</span> <span class="n">and</span> <span class="n">line</span> <span class="n">number</span> <span class="n">not</span> <span class="n">available</span><span class="o">):</span> <span class="n">kernel32</span><span class="o">.</span><span class="na">dll</span><span class="o">!</span><span class="n">BaseThreadInitThunk</span> <span class="o">+</span> <span class="mh">0x12</span> <span class="n">bytes</span>
    <span class="mh">0x77</span><span class="n">B8377B</span> <span class="o">(</span><span class="n">File</span> <span class="n">and</span> <span class="n">line</span> <span class="n">number</span> <span class="n">not</span> <span class="n">available</span><span class="o">):</span> <span class="n">ntdll</span><span class="o">.</span><span class="na">dll</span><span class="o">!</span><span class="n">RtlInitializeExceptionChain</span> <span class="o">+</span> <span class="mi">0</span><span class="n">xEF</span> <span class="n">bytes</span>
    <span class="mh">0x77</span><span class="n">B8374E</span> <span class="o">(</span><span class="n">File</span> <span class="n">and</span> <span class="n">line</span> <span class="n">number</span> <span class="n">not</span> <span class="n">available</span><span class="o">):</span> <span class="n">ntdll</span><span class="o">.</span><span class="na">dll</span><span class="o">!</span><span class="n">RtlInitializeExceptionChain</span> <span class="o">+</span> <span class="mi">0</span><span class="n">xC2</span> <span class="n">bytes</span>
  <span class="n">Data</span><span class="o">:</span>
    <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span>    <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span>    <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span>    <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span>     <span class="o">........</span> <span class="o">........</span>
    <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span>    <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span>    <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span>    <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span>     <span class="o">........</span> <span class="o">........</span>
    <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span>    <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span> <span class="n">CD</span>                                   <span class="o">........</span> <span class="o">........</span>


<span class="n">Visual</span> <span class="n">Leak</span> <span class="n">Detector</span> <span class="n">detected</span> <span class="mi">1</span> <span class="n">memory</span> <span class="n">leak</span> <span class="o">(</span><span class="mi">76</span> <span class="n">bytes</span><span class="o">).</span>
<span class="n">Largest</span> <span class="n">number</span> <span class="n">used</span><span class="o">:</span> <span class="mi">76</span> <span class="n">bytes</span><span class="o">.</span>
<span class="n">Total</span> <span class="n">allocations</span><span class="o">:</span> <span class="mi">76</span> <span class="n">bytes</span><span class="o">.</span>
<span class="n">Visual</span> <span class="n">Leak</span> <span class="n">Detector</span> <span class="k">is</span> <span class="n">now</span> <span class="n">exiting</span><span class="o">.</span>
<span class="n">The</span> <span class="n">program</span> <span class="s1">'[7652] leak.exe'</span> <span class="n">has</span> <span class="n">exited</span> <span class="k">with</span> <span class="n">code</span> <span class="mi">0</span> <span class="o">(</span><span class="mh">0x0</span><span class="o">).</span>
</pre></div>


<p>这里就很明白了把，这个vld工具可以打印出泄露调用的堆栈，双击任意错误处，可以到达错误的地方，e:\projects\leak\leak\source.cpp (6): leak.exe!main + 0x7 bytes双击这句话就定位到了main函数的第六行。哈哈，很方便吧！</p>
<p>使用Linux的童鞋要鄙视我们了，人家都是命令行的高手，不屑于使用GUI工具，再说也木有Visual Studio，Vim Emacs之类的利器可以秒杀Visual Studio。这时候如何定位泄露的地方呢？现在推出终极杀人魔——valgrind。官网：<a href="http://www.valgrind.org" title="http://www.valgrind.org">valgrind</a></p>
<p>使用debian和ubuntu的童鞋可以使用apt-get命令安装此软件。</p>
<p>首先使用gcc的童鞋首先编译的时候加上-g的debug选项，优化最好是使用-o0，然后如果你的程序运行是使用如下的参数方式：</p>
<div class="code"><pre><span class="n">myprog</span> <span class="n">arg1</span> <span class="n">arg2</span>
</pre></div>


<p>现在就改成下面的方式：</p>
<div class="code"><pre><span class="n">valgrind</span><span class="o">--</span><span class="n">leak</span><span class="o">-</span><span class="n">check</span><span class="o">=</span><span class="n">yes</span> <span class="n">myprog</span> <span class="n">arg1</span> <span class="n">arg2</span>
</pre></div>


<p>等到程序结束的时候就可以看到泄露的地方啦。（本人Linux菜鸟，没法给大家演示了，不然又要重启进入Linux或者打开卡卡的虚拟机）</p>
<p>哈哈，到这里了，泄露还是否那么可怕呢。我给大家一张恐怖的泄露截图吧，以供娱乐：</p>
<p><img alt="image" src="galleries/memory-leak/leak.jpg"></p>
<p>参考资料：</p>
<p>[1] <a href="http://bbs.csdn.net/topics/390050717">http://bbs.csdn.net/topics/390050717</a></p>
<p>[2] <a href="http://vld.codeplex.com/documentation">http://vld.codeplex.com/documentation</a></p>
<p>[3] <a href="http://www.valgrind.org/docs/manual/quick-start.html#quick-start.mcrun">http://www.valgrind.org/docs/manual/quick-start.html#quick-start.mcrun</a></p>
            
        
    <p>
        <a href="posts/oh-memory-leak.html#disqus_thread" data-disqus-identifier="cache\posts\oh-memory-leak.html">Comments</a>


        </p></div>
    
<div>
<ul class="pager">
</ul>
</div>

    
        
       <script type="text/javascript">var disqus_shortname="nikolademo";(function(){var a=document.createElement("script");a.async=true;a.type="text/javascript";a.src="http://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)}());</script>


	


    </div>
    </div>
    <!--End of body content-->
</div>
<div class="footerbox">
    Contents © 2014         <a href="mailto:chengximing1989@gmail.com">程光曦微</a> - Powered by         <a href="http://getnikola.com">Nikola</a>         
</div>

            <script src="assets/js/jquery-1.10.2.min.js" type="text/javascript"></script>
            <script src="assets/js/bootstrap.min.js" type="text/javascript"></script>
        <script src="assets/js/jquery.colorbox-min.js" type="text/javascript"></script>


	
<!-- Social buttons -->
<div id="addthisbox" class="addthis_toolbox addthis_peekaboo_style addthis_default_style addthis_label_style addthis_32x32_style">
<a class="addthis_button_more">Share</a>
<ul><li><a class="addthis_button_facebook"></a>
</li><li><a class="addthis_button_google_plusone_share"></a>
</li><li><a class="addthis_button_linkedin"></a>
</li><li><a class="addthis_button_twitter"></a>
</li></ul>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-4f7088a56bb93798"></script>
<!-- End of social buttons -->


    <script type="text/javascript">jQuery("a.image-reference").colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});
    $(window).on('hashchange', function(){
        if (location.hash && $(location.hash)[0]) {
            $('body').animate({scrollTop: $(location.hash).offset().top - $('#navbar').outerHeight(true)*1.2 }, 1);
        }
    });
    $(document).ready(function(){$(window).trigger('hashchange')});
    </script>
   
   
</body>
</html>